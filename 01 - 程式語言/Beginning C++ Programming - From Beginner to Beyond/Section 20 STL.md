# ğŸŒ² C++ STL æ¦‚è¿°

STL æ˜¯ C++ æä¾›çš„ä¸€å¥—**æ³›å‹è³‡æ–™çµæ§‹èˆ‡æ¼”ç®—æ³•å·¥å…·åº«**ï¼Œæ”¯æ´ï¼š

1. **å®¹å™¨ Containers**ï¼šç”¨ä¾†å„²å­˜è³‡æ–™
    
2. **æ¼”ç®—æ³• Algorithms**ï¼šæ“ä½œå®¹å™¨ä¸­çš„è³‡æ–™ï¼ˆå¦‚æ’åºã€æœå°‹ç­‰ï¼‰
    
3. **ç–Šä»£å™¨ Iterators**ï¼šåœ¨å®¹å™¨ä¸­ç§»å‹•èˆ‡å­˜å–è³‡æ–™çš„å·¥å…·
    
4. **å‡½å¼ç‰©ä»¶ Function Objectsï¼ˆå‡½æ•¸ç‰©ä»¶ï¼‰**
    
5. **é…æ¥å™¨ Adapters**ï¼šè®Šæ›´å®¹å™¨æˆ–å‡½å¼çš„è¡Œç‚º
    
6. **é…æ¥å™¨è¨˜æ†¶é«”é…ç½®å™¨ Allocatorsï¼ˆé€²éšï¼‰**
    

STL çš„æ ¸å¿ƒç²¾ç¥æ˜¯ã€Œ**æ³›å‹ç¨‹å¼è¨­è¨ˆ**ã€ï¼ˆGeneric Programmingï¼‰ï¼šä½¿ç”¨æ¨¡æ¿ï¼ˆtemplateï¼‰ä¾†å¯«ä¸ä¾è³´ç‰¹å®šå‹åˆ¥çš„ç¨‹å¼ã€‚

---

# ğŸ§© ä»€éº¼æ˜¯ Function Templateï¼Ÿ

**Function Template** æ˜¯ä¸€ç¨®å…è¨±å‡½å¼åœ¨**ä¸æŒ‡å®šå…·é«”è³‡æ–™å‹åˆ¥**ä¸‹æ’°å¯«çš„æ©Ÿåˆ¶ï¼Œé€é C++ çš„æ¨¡æ¿ï¼ˆtemplateï¼‰åŠŸèƒ½ä¾†å¯¦ç¾ **æ³›å‹å‡½å¼**ã€‚

ğŸ‘‰ å®ƒçš„ç›®çš„æ˜¯ã€Œ**è®“å‡½å¼å¯ä»¥ä½œç”¨æ–¼å¤šç¨®å‹åˆ¥**ã€ï¼Œè€Œä¸ç”¨ç‚ºæ¯å€‹å‹åˆ¥éƒ½æ‰‹å‹•é‡è¤‡å¯«ä¸€æ¬¡ã€‚

---

## ğŸ§ª åŸºæœ¬èªæ³•

```cpp
template <typename T>
T functionName(T a, T b) {
    // ä½¿ç”¨å‹åˆ¥ T æ’°å¯«é€šç”¨é‚è¼¯
}
```

æˆ–ï¼š

```cpp
template <class T>  // class å’Œ typename ç­‰åƒ¹
T functionName(T a, T b) {
    // ...
}
```

### ç¯„ä¾‹ï¼šå–å¾—å…©æ•¸çš„æœ€å¤§å€¼

```cpp
#include <iostream>
using namespace std;

template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << getMax(10, 20) << endl;       // int
    cout << getMax(3.14, 2.71) << endl;   // double
    cout << getMax('a', 'z') << endl;     // char
}
```

---

## ğŸ”§ å‡½å¼æ¨¡æ¿çš„æ¨å°ï¼ˆType Deductionï¼‰

ä½ é€šå¸¸ **ä¸éœ€è¦æ‰‹å‹•æŒ‡å®šå‹åˆ¥**ï¼Œç·¨è­¯å™¨æœƒè‡ªå‹•å¾åƒæ•¸æ¨æ–·æ¨¡æ¿å‹åˆ¥ï¼š

```cpp
getMax(10, 20);    // æ¨æ–· T ç‚º int
getMax(1.5, 3.2);  // æ¨æ–· T ç‚º double
```

ä½†ä½ ä¹Ÿ**å¯ä»¥æ‰‹å‹•æŒ‡å®šå‹åˆ¥**ï¼š

```cpp
getMax<double>(2, 3);  // å°‡ int è½‰æˆ doubleï¼Œå¼·åˆ¶ä½¿ç”¨ double æ¨¡æ¿
```

## ğŸŒˆ å¤šå€‹æ¨¡æ¿åƒæ•¸

```cpp
template <typename T1, typename T2>
class Pair {
    T1 first;
    T2 second;
public:
    Pair(T1 f, T2 s) : first(f), second(s) {}
    void print() { std::cout << first << " - " << second << '\n'; }
};

Pair<int, string> p(1, "apple");
```


## âš ï¸ å‡½å¼æ¨¡æ¿èˆ‡ Overloadï¼ˆå¤šè¼‰ï¼‰ä¸¦å­˜

å‡½å¼æ¨¡æ¿å’Œæ™®é€šå‡½å¼å¯ä»¥å…±å­˜ï¼Œç·¨è­¯å™¨æœƒæ ¹æ“šã€Œæœ€ç¬¦åˆçš„ã€ä¾†é¸æ“‡ï¼š

```cpp
int getMax(int a, int b) {
    cout << "Regular function\n";
    return (a > b) ? a : b;
}

template <typename T>
T getMax(T a, T b) {
    cout << "Template function\n";
    return (a > b) ? a : b;
}

int main() {
    getMax(3, 4);     // å‘¼å« regular ç‰ˆæœ¬ï¼ˆå®Œå…¨åŒ¹é…ï¼‰
    getMax(3.0, 4.0); // å‘¼å« template ç‰ˆæœ¬
}
```

---

## ğŸ› ï¸ é™åˆ¶å‹åˆ¥ï¼š`requires`ï¼ˆC++20ï¼‰æˆ– `enable_if`ï¼ˆC++11ï¼‰

ä¾‹å¦‚é™åˆ¶åªèƒ½å°å¯æ¯”è¼ƒå¤§å°çš„å‹åˆ¥ä½¿ç”¨ï¼š

```cpp
#include <concepts>

template <typename T>
requires std::totally_ordered<T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}
```

---

## ğŸ§¿ æ¨¡æ¿å¯¦ä¾‹åŒ–ï¼ˆInstantiationï¼‰

ç•¶ä½ å‘¼å«ä¸€å€‹æ¨¡æ¿å‡½å¼æ™‚ï¼Œç·¨è­¯å™¨æœƒã€Œç”¢ç”Ÿã€å°æ‡‰å‹åˆ¥çš„ç‰ˆæœ¬ï¼š

```cpp
getMax(1, 2);        // ç”¢ç”Ÿ getMax<int>(int, int)
getMax(1.5, 2.5);    // ç”¢ç”Ÿ getMax<double>(double, double)
```

é€™å«åš **template instantiation**ã€‚

---

## ğŸ§µ å°çµï¼šFunction Template çš„å„ªé»

|å„ªé»|èªªæ˜|
|---|---|
|ç¯€çœç¨‹å¼ç¢¼é‡è¤‡|å¯«ä¸€æ¬¡å°±èƒ½æ”¯æ´å¤šç¨®å‹åˆ¥|
|å¢å¼·å‹åˆ¥å®‰å…¨|ç·¨è­¯æ™‚æª¢æŸ¥å‹åˆ¥éŒ¯èª¤|
|æ˜“æ–¼ç¶­è­·|åƒæ¨™æº–å‡½å¼ `std::swap`ã€`std::max` å°±æ˜¯æ¨¡æ¿å¯«æˆçš„|

---

# ğŸ—ï¸ ä»€éº¼æ˜¯ Class Templateï¼Ÿ

**Class Template** æ˜¯ C++ æä¾›çš„ä¸€ç¨®æ©Ÿåˆ¶ï¼Œè®“ä½ å¯ä»¥ç‚ºä»»æ„å‹åˆ¥å»ºç«‹ã€Œé€šç”¨é¡åˆ¥ã€ï¼Œå¯«ä¸€ä»½é¡åˆ¥ç¨‹å¼ç¢¼ï¼Œå°±å¯ä»¥å°ä¸åŒå‹åˆ¥çš„è³‡æ–™ä½¿ç”¨ã€‚

## âœ… ç›®çš„

é¡ä¼¼æ–¼å‡½å¼æ¨¡æ¿çš„ã€Œå‹åˆ¥æ³›åŒ–ã€ï¼Œä½†é‡å°çš„æ˜¯**é¡åˆ¥å±¤ç´š**ã€‚

---

## ğŸ“ åŸºæœ¬èªæ³•

```cpp
template <typename T>
class ClassName {
public:
    T data;

    ClassName(T val) : data(val) {}

    void display() {
        std::cout << data << std::endl;
    }
};
```

### ğŸ§ª ä½¿ç”¨ç¯„ä¾‹

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Box {
    T value;
public:
    Box(T val) : value(val) {}
    void show() const {
        cout << "Value: " << value << endl;
    }
};

int main() {
    Box<int> intBox(123);
    Box<string> strBox("Hello");

    intBox.show();   // Value: 123
    strBox.show();   // Value: Hello
}
```

---

## ğŸ§¬ ä½¿ç”¨æ¨¡æ¿åƒæ•¸çš„æˆå“¡å‡½å¼

ä½ å¯ä»¥åœ¨é¡åˆ¥å…§éƒ¨ä½¿ç”¨æ¨¡æ¿å‹åˆ¥ `T`ï¼Œä¹Ÿå¯ä»¥å®šç¾©æ¨¡æ¿æˆå“¡å‡½å¼ï¼š

```cpp
template <typename T>
class Wrapper {
    T item;
public:
    Wrapper(T val) : item(val) {}

    void print() {
        std::cout << "Item = " << item << '\n';
    }

    T get() {
        return item;
    }
};
```

---

## ğŸ§  æ¨¡æ¿é¡åˆ¥çš„å¯¦ä¾‹åŒ–ï¼ˆInstantiationï¼‰

ç•¶ä½ ä½¿ç”¨ `Box<int>` æ™‚ï¼Œç·¨è­¯å™¨å°±æœƒæ ¹æ“šæ¨¡æ¿ç”¢ç”Ÿä¸€å€‹å°ˆé–€çš„é¡åˆ¥ `Box<int>`ã€‚

ä½ ä¹Ÿå¯ä»¥é¡¯å¼æŒ‡å®šï¼š

```cpp
Box<double> b(3.14);
```

---

# ğŸ”§ åˆ†é›¢å®£å‘Šèˆ‡å®šç¾©ï¼ˆåœ¨ `.h` / `.cpp` åˆ†é–‹ï¼‰

## âŒ éŒ¯èª¤æ–¹å¼ï¼ˆé€™æœƒé€ æˆ linker éŒ¯èª¤ï¼‰

**Box.h**

```cpp
template <typename T>
class Box {
public:
    Box(T val);
    void show();
};
```

**Box.cpp**

```cpp
template <typename T>
Box<T>::Box(T val) { ... }  // éŒ¯èª¤ï¼šç„¡æ³•ç·¨è­¯æ¨¡æ¿å®šç¾©æ–¼ .cpp
```

## âœ… æ­£ç¢ºæ–¹å¼ï¼ˆéƒ½å¯«åœ¨ `.h`ï¼‰

å› ç‚º template æ˜¯åœ¨ç·¨è­¯æœŸå¯¦é«”åŒ–çš„ï¼Œ**å¿…é ˆæä¾›å®Œæ•´å®šç¾©**ã€‚

```cpp
// Box.h
template <typename T>
class Box {
    T value;
public:
    Box(T val) : value(val) {}
    void show() const { std::cout << value << std::endl; }
};
```


## ğŸ§© Class Template èˆ‡ Function Template æ¯”è¼ƒ

| åŠŸèƒ½       | Function Template | Class Template                    |
| -------- | ----------------- | --------------------------------- |
| ä½œç”¨ç¯„åœ     | å–®ä¸€å‡½å¼              | æ•´å€‹é¡åˆ¥                              |
| å¸¸è¦‹æ‡‰ç”¨     | `max`, `swap`     | `vector`, `stack`, `map` ç­‰ STL é¡åˆ¥ |
| å¯¦ä¾‹åŒ–æ™‚é–“    | å‘¼å«æ™‚               | å®£å‘Šæ™‚                               |
| æ¨¡æ¿åƒæ•¸ä½¿ç”¨ä½ç½® | å‡½å¼åƒæ•¸èˆ‡å›å‚³å‹åˆ¥         | æˆå“¡è®Šæ•¸èˆ‡å‡½å¼                           |

# ğŸ¨ Template Specializationï¼ˆæ¨¡æ¿ç‰¹åŒ–ï¼‰

### ğŸ§Š å…¨ç‰¹åŒ–ï¼šé‡å°ç‰¹å®šå‹åˆ¥å¯«ç‰¹æ®Šç‰ˆæœ¬

```cpp
template <>
class Box<string> {
public:
    Box(string s) { std::cout << "Specialized: " << s << std::endl; }
};
```

## ğŸ§µ å°çµï¼šClass Template çš„å„ªé»

|å„ªé»|èªªæ˜|
|---|---|
|æ³›å‹è¨­è¨ˆ|æ”¯æ´ä»»æ„å‹åˆ¥|
|é‡è¤‡åˆ©ç”¨|å¯æ¸›å°‘æ’°å¯«å¤šå‹åˆ¥ç‰ˆæœ¬çš„é¡åˆ¥|
|é¡ä¼¼ STL é¡åˆ¥çµæ§‹|å¯æ¨¡æ“¬ `vector<T>`, `stack<T>` ç­‰çµæ§‹|

## ğŸ“¦ STL ä¸­çš„ä¾‹å­ï¼švector å°±æ˜¯ class template

```cpp
std::vector<int> v1;
std::vector<double> v2;
std::vector<std::string> v3;
```

---

# ğŸ§© ä»€éº¼æ˜¯ Generic Array classï¼Ÿ

ã€ŒGeneric Array classã€æ˜¯ä¸€å€‹**å¯ä»¥å­˜ä»»æ„å‹åˆ¥çš„é¡åˆ¥åŒ–é™£åˆ—å®¹å™¨**ï¼Œé€é template å¯¦ä½œï¼Œåƒé€™æ¨£ä½¿ç”¨ï¼š

```cpp
Array<int> intArr(5);      // å»ºç«‹ä¸€å€‹ int å‹æ…‹çš„é™£åˆ—
Array<string> strArr(3);   // å»ºç«‹ä¸€å€‹ string å‹æ…‹çš„é™£åˆ—
```

## ğŸ—ï¸ ç¯„ä¾‹å¯¦ä½œï¼šç°¡æ˜“ç‰ˆ Generic Array class

### ğŸ”§ åŠŸèƒ½ç›®æ¨™

- å»ºç«‹é™£åˆ—
    
- è¨­å®šå…ƒç´ ã€å–å¾—å…ƒç´ 
    
- è‡ªå‹•ç®¡ç†è¨˜æ†¶é«”ï¼ˆé¿å…è¨˜æ†¶é«”æ´©æ¼ï¼‰
    
- æ”¯æ´ç´¢å¼•é‹ç®—å­ï¼ˆoperator[]ï¼‰
    

---

### ğŸ§ª ç¨‹å¼ç¢¼

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Array {
private:
    T* data;
    size_t size;

public:
    // Constructor
    Array(size_t n) : size(n) {
        data = new T[n];
    }

    // Destructor
    ~Array() {
        delete[] data;
    }

    // Copy constructor
    Array(const Array& other) : size(other.size) {
        data = new T[size];
        for (size_t i = 0; i < size; ++i)
            data[i] = other.data[i];
    }

    // Assignment operator
    Array& operator=(const Array& other) {
        if (this == &other) return *this; // é˜²æ­¢è‡ªå·±æŒ‡æ´¾è‡ªå·±
        delete[] data;
        size = other.size;
        data = new T[size];
        for (size_t i = 0; i < size; ++i)
            data[i] = other.data[i];
        return *this;
    }

    // ç´¢å¼•é‹ç®—å­
    T& operator[](size_t index) {
        if (index >= size) throw out_of_range("Index out of range");
        return data[index];
    }

    // const ç‰ˆæœ¬
    const T& operator[](size_t index) const {
        if (index >= size) throw out_of_range("Index out of range");
        return data[index];
    }

    // å–å¾—å¤§å°
    size_t getSize() const { return size; }
};
```

### ğŸ“¦ ä½¿ç”¨ç¯„ä¾‹

```cpp
int main() {
    Array<int> nums(5);
    for (int i = 0; i < nums.getSize(); ++i)
        nums[i] = i * i;

    for (int i = 0; i < nums.getSize(); ++i)
        cout << nums[i] << " ";
    cout << endl;

    Array<string> words(3);
    words[0] = "Hello";
    words[1] = "World";
    words[2] = "!";

    for (int i = 0; i < words.getSize(); ++i)
        cout << words[i] << " ";
}
```

## âœ¨ å¯åŠ å¼·çš„åŠŸèƒ½ï¼ˆé€²éšï¼‰

| åŠŸèƒ½         | æŠ€è¡“                                |
| ---------- | --------------------------------- |
| ç¯„åœæª¢æŸ¥       | è‡ªè¨‚éŒ¯èª¤è™•ç†æˆ–ä¾‹å¤–æ‹‹å‡º                       |
| å‹•æ…‹èª¿æ•´å¤§å°     | åŠ å…¥ `resize()` æˆ–æ”¹ç‚º vector-like     |
| ç–Šä»£å™¨æ”¯æ´      | æä¾› `begin()`, `end()`             |
| ç§»å‹•å»ºæ§‹å­èˆ‡ç§»å‹•æŒ‡æ´¾ | C++11 `&&` æ­é… `std::move()`       |
| åˆå§‹åŒ–åˆ—è¡¨å»ºæ§‹å­   | `Array(std::initializer_list<T>)` |

## ğŸ§  èˆ‡ `std::vector` çš„æ¯”è¼ƒ

| ç‰¹æ€§    | Generic Array class | `std::vector` |
| ----- | ------------------- | ------------- |
| è¨˜æ†¶é«”ç®¡ç† | æ‰‹å‹• `new/delete`     | è‡ªå‹•è™•ç†          |
| å‹•æ…‹æ“´å±•  | ä¸æ”¯æ´ï¼ˆå¯æ‰‹å‹•åŠ ï¼‰           | æ”¯æ´            |
| æ“ä½œç°¡æ˜“æ€§ | å­¸ç¿’ç”¨                 | ç”Ÿç”¢ç’°å¢ƒæ¨è–¦        |
| æ•ˆç‡    | å¥½æ§åˆ¶                 | æœ€ä½³åŒ–å·²å®Œæˆ        |

## ğŸ“˜ å°çµ

- Generic Array class æ˜¯è¨“ç·´ **template**ã€**è¨˜æ†¶é«”ç®¡ç†**ã€**ç‰©ä»¶å°å‘è¨­è¨ˆ**çš„å¥½ä¾‹å­ã€‚
    
- ä½ å¯ä»¥å¾é€™å€‹ç°¡å–®çš„ä¾‹å­å»¶ä¼¸å‡ºï¼š
    
    - **è‡ªè¨‚å®¹å™¨ï¼ˆå¦‚ Stackã€Queueï¼‰**
        
    - **ç†è§£ STL çš„åº•å±¤çµæ§‹**
        
    - **å­¸ç¿’ C++ 11/14/17 çš„ç¾ä»£æŠ€è¡“å¦‚ move semanticsã€initializer_list**
        

---

# ğŸ“¦ STL å®¹å™¨ Containers

![Pasted image 20250714091102](01%20-%20ç¨‹å¼èªè¨€/Beginning%20C++%20Programming%20-%20From%20Beginner%20to%20Beyond/attachments/Pasted%20image%2020250714091102.png)

---

## ğŸ”¢ Types of STL Containers

STL å®¹å™¨åˆ†ç‚ºä»¥ä¸‹å››å¤§é¡å‹ï¼Œæ¯ä¸€é¡éƒ½ä¾æ“šå…¶å„²å­˜èˆ‡æ“ä½œæ–¹å¼è¨­è¨ˆï¼Œä»¥é©ç”¨ä¸åŒçš„è³‡æ–™çµæ§‹éœ€æ±‚ã€‚

---

### ğŸ“š Sequence Containersï¼ˆåºåˆ—å¼å®¹å™¨ï¼‰

**ç”¨é€”**ï¼šç¶­æŒå…ƒç´ æ’å…¥é †åºï¼Œé¡ä¼¼é™£åˆ—æˆ–ä¸²åˆ—ã€‚  
**ç‰¹æ€§**ï¼šå…ƒç´ çš„æ’åˆ—é †åºä¾æ’å…¥ä½ç½®è€Œå®šï¼Œå¯é€éç´¢å¼•æˆ– iterator è¨ªå•ã€‚

|å®¹å™¨åç¨±|ç‰¹é»ç°¡è¿°|
|---|---|
|`vector`|å‹•æ…‹å¤§å°é™£åˆ—ï¼Œæ”¯æ´éš¨æ©Ÿå­˜å–ï¼Œæ“´å±•æ•ˆç‡ä½³|
|`deque`|é›™ç«¯ä½‡åˆ—ï¼Œæ”¯æ´å‰å¾Œæ’å…¥åˆªé™¤ï¼Œäº¦æ”¯æ´éš¨æ©Ÿå­˜å–|
|`list`|é›™å‘éˆçµä¸²åˆ—ï¼Œæ”¯æ´ä¸­é–“æ’å…¥åˆªé™¤ä½†ä¸æ”¯æ´éš¨æ©Ÿå­˜å–|
|`forward_list`|å–®å‘éˆçµä¸²åˆ—ï¼Œè¨˜æ†¶é«”ä½¿ç”¨æ›´çœä½†åŠŸèƒ½è¼ƒå°‘|
|`array`|å›ºå®šå¤§å°çš„éœæ…‹é™£åˆ—å®¹å™¨|
|`string`|å­—å…ƒåºåˆ—çš„å°è£ï¼Œé¡ä¼¼ `vector<char>`ï¼ˆå¯¦éš›ä¸Šæ˜¯å€‹ç‰¹æ®Šå®¹å™¨ï¼‰|

ğŸ”§ **å…¸å‹ä½¿ç”¨å ´æ™¯**ï¼šéœ€è¦é »ç¹è¨ªå•ï¼ˆå¦‚ `vector`ï¼‰ã€é »ç¹æ’å…¥åˆªé™¤ï¼ˆå¦‚ `list`ï¼‰

---

### ğŸ—‚ï¸ Associative Containersï¼ˆé—œè¯å¼å®¹å™¨ï¼‰

**ç”¨é€”**ï¼šä»¥éµå€¼ï¼ˆkeyï¼‰ç‚ºåŸºç¤æ’åºèˆ‡å­˜å–å…ƒç´ ã€‚  
**ç‰¹æ€§**ï¼šå…§éƒ¨ä»¥å¹³è¡¡äºŒå…ƒæœå°‹æ¨¹ï¼ˆå¦‚ Red-Black Treeï¼‰å¯¦ä½œï¼Œæœƒè‡ªå‹•æ’åºã€‚

| å®¹å™¨åç¨±       | ç‰¹é»ç°¡è¿°h                             |
| ---------- | --------------------------------- |
| `set`      | å”¯ä¸€ä¸”æ’åºçš„éµé›†åˆï¼Œå…ƒç´ å³ç‚º key                |
| `multiset` | å¯é‡è¤‡å…ƒç´ çš„æ’åºé›†åˆ                        |
| `map`      | éµå€¼å° (key-value pair)ï¼Œkey å”¯ä¸€ï¼Œæœƒè‡ªå‹•æ’åº |
| `multimap` | å¯é‡è¤‡ key çš„éµå€¼å°é›†åˆ                    |

ğŸ” **å…¸å‹ä½¿ç”¨å ´æ™¯**ï¼šéœ€è¦è‡ªå‹•æ’åºèˆ‡å¿«é€ŸæŸ¥æ‰¾å…ƒç´ çš„å ´æ™¯ã€‚

---

### ğŸŒ Unordered Containersï¼ˆéæ’åºé—œè¯å¼å®¹å™¨ï¼‰

**ç”¨é€”**ï¼šæä¾›åŸºæ–¼é›œæ¹Šï¼ˆhashï¼‰çš„å¿«é€ŸæŸ¥æ‰¾ï¼Œä¸ä¿è­‰å…ƒç´ é †åºã€‚  
**ç‰¹æ€§**ï¼šå…§éƒ¨ä»¥ Hash Table å¯¦ä½œï¼Œå¹³å‡ O(1) æŸ¥æ‰¾èˆ‡æ’å…¥æ•ˆç‡ã€‚

|å®¹å™¨åç¨±|ç‰¹é»ç°¡è¿°|
|---|---|
|`unordered_set`|å”¯ä¸€éµçš„ hash-based é›†åˆ|
|`unordered_multiset`|å¯é‡è¤‡éµçš„ hash-based é›†åˆ|
|`unordered_map`|éµå€¼å°é›†åˆï¼Œkey å”¯ä¸€|
|`unordered_multimap`|å¯é‡è¤‡éµçš„éµå€¼å°é›†åˆ|

âš¡ **å…¸å‹ä½¿ç”¨å ´æ™¯**ï¼šéœ€è¦æœ€å¿«é€ŸæŸ¥æ‰¾ä¸”ä¸åœ¨ä¹é †åºçš„æƒ…æ³ã€‚

---

### ğŸ§± Container Adaptersï¼ˆå®¹å™¨é…æ¥å™¨ï¼‰

**ç”¨é€”**ï¼šæä¾›ç‰¹å®šæŠ½è±¡è³‡æ–™çµæ§‹ï¼ˆå¦‚ stackã€queueï¼‰çš„æ¥å£ï¼Œå¯¦éš›ä»¥å…¶ä»–å®¹å™¨ç‚ºåº•å±¤å¯¦ä½œã€‚  
**ç‰¹æ€§**ï¼šé™åˆ¶ä»‹é¢ï¼ˆåªèƒ½ push/pop/top ç­‰ï¼‰ï¼Œä»¥ `deque` æˆ– `vector` ä½œç‚ºåº•å±¤å„²å­˜ã€‚

|å®¹å™¨åç¨±|ç‰¹é»ç°¡è¿°|
|---|---|
|`stack`|å¾Œé€²å…ˆå‡ºï¼ˆLIFOï¼‰ï¼Œåƒ…å¯å¾é ‚ç«¯æ“ä½œ|
|`queue`|å…ˆé€²å…ˆå‡ºï¼ˆFIFOï¼‰ï¼Œå¾å°¾éƒ¨æ’å…¥ã€å‰ç«¯å–å‡º|
|`priority_queue`|å…ƒç´ è‡ªå‹•æ’åºçš„ queueï¼Œé è¨­ç‚ºå¤§æ ¹å †ï¼ˆæœ€å¤§å€¼å„ªå…ˆï¼‰|

ğŸ”„ **å…¸å‹ä½¿ç”¨å ´æ™¯**ï¼šéœ€è¦æ¨¡æ“¬è³‡æ–™çµæ§‹ï¼Œå¦‚ DFS ä½¿ç”¨ `stack`ã€BFS ä½¿ç”¨ `queue`ã€æ¨¡æ“¬äº‹ä»¶è™•ç†ä½¿ç”¨ `priority_queue`ã€‚

---
# ğŸ“š Sequence Containers

## ğŸ“¦ `std::vector` â€” å‹•æ…‹é™£åˆ—å®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::vector` æ˜¯ä¸€ç¨®å‹•æ…‹å¤§å°çš„ä¸€ç¶­é™£åˆ—å®¹å™¨ï¼Œæ”¯æ´éš¨æ©Ÿå­˜å–ï¼ˆrandom accessï¼‰ï¼Œå…ƒç´ æœƒæŒ‰ç…§æ’å…¥é †åºæ’åˆ—ã€‚å®ƒçš„å¤§å°å¯åœ¨åŸ·è¡Œæ™‚æ ¹æ“šéœ€æ±‚è‡ªå‹•æ“´å¼µã€‚

### ğŸ§± å…§éƒ¨å¯¦ä½œ

- åº•å±¤æ˜¯é€£çºŒè¨˜æ†¶é«”å€æ®µï¼ˆcontiguous memoryï¼‰ï¼Œé¡ä¼¼ C-style é™£åˆ—ã€‚
    
- ç•¶è¶…å‡ºå®¹é‡æ™‚ï¼Œæœƒé‡æ–°é…ç½®æ›´å¤§çš„è¨˜æ†¶é«”ä¸¦æ¬ç§»èˆŠå…ƒç´ ã€‚
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

| æ–¹æ³•                   | èªªæ˜                      |
| -------------------- | ----------------------- |
| `vector<T> v;`       | å»ºç«‹ç©ºçš„ vector             |
| `vector<T> v(n);`    | å»ºç«‹æœ‰ n å€‹é è¨­å€¼çš„ vector      |
| `v.push_back(val);`  | å°‡ `val` åŠ å…¥ vector æœ«å°¾    |
| `v.pop_back();`      | ç§»é™¤æœ€å¾Œä¸€å€‹å…ƒç´                 |
| `v.size();`          | å›å‚³ç›®å‰å…ƒç´ å€‹æ•¸                |
| `v.capacity();`      | å›å‚³ç›®å‰è¨˜æ†¶é«”é…ç½®å®¹é‡             |
| `v.reserve(n);`      | æå‰é…ç½®è‡³å°‘ n å€‹å…ƒç´ çš„ç©ºé–“         |
| `v.resize(n);`       | èª¿æ•´å…ƒç´ å€‹æ•¸ç‚º nï¼Œå¯èƒ½æœƒåŠ æ–°å…ƒç´ æˆ–ç§»é™¤å°¾éƒ¨  |
| `v.clear();`         | ç§»é™¤æ‰€æœ‰å…ƒç´ ä½†ä¸é‡‹æ”¾è¨˜æ†¶é«”           |
| `v.empty();`         | å›å‚³æ˜¯å¦ç‚ºç©ºå®¹å™¨                |
| `v[i] / at(i)`       | å­˜å–ç¬¬ i å€‹å…ƒç´ ï¼Œ`at(i)` æœ‰ç•Œé™æª¢æŸ¥ |
| `v.begin(), v.end()` | iterator èµ·å§‹èˆ‡çµå°¾          |
| `v.insert(pos, val)` | æ’å…¥å…ƒç´ åˆ°æŒ‡å®š iterator ä½ç½®     |
| `v.erase(pos)`       | ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´        |

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums;

    // åŠ å…¥å…ƒç´ 
    nums.push_back(10);
    nums.push_back(20);
    nums.push_back(30);

    // ä½¿ç”¨ç´¢å¼•è¨ªå•
    std::cout << "ç¬¬äºŒå€‹å…ƒç´ : " << nums[1] << '\n';

    // ä½¿ç”¨ç¯„åœ for loop
    std::cout << "æ‰€æœ‰å…ƒç´ : ";
    for (int x : nums)
        std::cout << x << " ";
    std::cout << '\n';

    // ç§»é™¤æœ€å¾Œä¸€å€‹å…ƒç´ 
    nums.pop_back();

    // æŸ¥çœ‹å¤§å°èˆ‡å®¹é‡
    std::cout << "å¤§å°: " << nums.size() << ", å®¹é‡: " << nums.capacity() << '\n';

    // æ’å…¥èˆ‡åˆªé™¤
    nums.insert(nums.begin() + 1, 99);  // åœ¨ç¬¬äºŒå€‹ä½ç½®æ’å…¥ 99
    nums.erase(nums.begin());           // ç§»é™¤ç¬¬ä¸€å€‹å…ƒç´ 

    // è¼¸å‡ºä¿®æ”¹å¾Œ
    std::cout << "ä¿®æ”¹å¾Œ: ";
    for (int x : nums)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- é ˆé »ç¹**éš¨æ©Ÿå­˜å–**å…ƒç´ 
    
- å…ƒç´ æ•¸é‡**æœƒå‹•æ…‹è®ŠåŒ–**ä¸”é€šå¸¸æ–°å¢åœ¨æœ«å°¾
    
- è¿½æ±‚**ç·Šæ¹Šã€é«˜æ•ˆçš„è¨˜æ†¶é«”é…ç½®**
    

### âš ï¸ æ³¨æ„äº‹é …

- **æ’å…¥æˆ–åˆªé™¤å‰é¢çš„å…ƒç´ **æ•ˆç‡å·®ï¼Œå› ç‚ºæœƒå°è‡´æ‰€æœ‰å¾Œé¢å…ƒç´ æ¬ç§»ã€‚
    
- é‡æ–°é…ç½®ï¼ˆreallocationï¼‰æœƒ**ä½¿æ‰€æœ‰ iterator èˆ‡æŒ‡æ¨™å¤±æ•ˆ**ã€‚
    

---
## ğŸ“¦ `std::deque` â€” é›™ç«¯ä½‡åˆ—å®¹å™¨ï¼ˆDouble-Ended Queueï¼‰

### ğŸ“˜ æ¦‚è¦

`std::deque`ï¼ˆ**D**ouble-**Ended QUE**ueï¼‰æ˜¯æ”¯æ´å…©ç«¯æ’å…¥èˆ‡åˆªé™¤çš„å®¹å™¨ï¼Œé¡ä¼¼ `vector`ï¼Œä½†åœ¨å‰ç«¯æ“ä½œæ•ˆç‡æ›´å¥½ã€‚å®ƒåŒæ¨£æ”¯æ´éš¨æ©Ÿå­˜å–ã€‚

### ğŸ§± å…§éƒ¨å¯¦ä½œ

ä¸åƒ `vector` ä½¿ç”¨é€£çºŒè¨˜æ†¶é«”ï¼Œ`deque` æ˜¯ä¸€çµ„æŒ‡å‘å¤šå€‹å›ºå®šå¤§å°å€å¡Šçš„é™£åˆ—ï¼Œå¯¦ç¾ã€Œå½ˆæ€§å‰å¾Œæ“´å¼µã€çš„æ•ˆæœã€‚

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

| æ–¹æ³•                         | èªªæ˜                  |
| -------------------------- | ------------------- |
| `deque<T> d;`              | å»ºç«‹ç©ºçš„ deque          |
| `d.push_back(val);`        | åœ¨å°¾ç«¯åŠ å…¥å…ƒç´              |
| `d.push_front(val);`       | åœ¨å‰ç«¯åŠ å…¥å…ƒç´              |
| `d.pop_back();`            | ç§»é™¤å°¾ç«¯å…ƒç´               |
| `d.pop_front();`           | ç§»é™¤å‰ç«¯å…ƒç´               |
| `d.front();` / `d.back();` | å­˜å–æœ€å‰/æœ€å¾Œä¸€å€‹å…ƒç´          |
| `d[i]` / `d.at(i)`         | éš¨æ©Ÿå­˜å–å…ƒç´ ï¼ˆO(1))        |
| `d.size();`                | å›å‚³å…ƒç´ å€‹æ•¸              |
| `d.clear();`               | æ¸…ç©ºæ‰€æœ‰å…ƒç´               |
| `d.empty();`               | å›å‚³æ˜¯å¦ç‚ºç©º              |
| `d.insert(pos, val)`       | æ’å…¥å…ƒç´ åˆ°æŒ‡å®š iterator ä½ç½® |
| `d.erase(pos)`             | ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´    |
| `d.begin(), d.end()`       | Iterator èµ·è¿„ä½ç½®       |

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;

    // å‰å¾Œæ’å…¥
    dq.push_back(10);
    dq.push_front(5);
    dq.push_back(20);

    // ç¾åœ¨é †åºç‚º 5 10 20
    std::cout << "ç›®å‰å…§å®¹: ";
    for (int x : dq)
        std::cout << x << " ";
    std::cout << '\n';

    // ç§»é™¤å…©ç«¯
    dq.pop_front(); // ç§»é™¤ 5
    dq.pop_back();  // ç§»é™¤ 20

    std::cout << "ä¸­é–“åªå‰©: " << dq.front() << '\n'; // å°å‡º 10

    // æ’å…¥èˆ‡åˆªé™¤
    dq.push_back(99);
    dq.insert(dq.begin() + 1, 42); // åœ¨ä¸­é–“æ’å…¥

    std::cout << "æ’å…¥å¾Œå…§å®¹: ";
    for (int x : dq)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦åœ¨**å‰å¾Œéƒ½èƒ½é«˜æ•ˆæ’å…¥/åˆªé™¤**çš„å ´æ™¯ï¼ˆå¦‚ï¼šæ¨¡æ“¬æ»‘å‹•è¦–çª—ã€BFSï¼‰
    
- æ¯” `list` æ›´çœç©ºé–“ï¼Œä¸”ä»æä¾›å¸¸æ•¸æ™‚é–“çš„å‰å¾Œæ“ä½œ
    

### âš ï¸ æ³¨æ„äº‹é …

- é›–æ”¯æ´éš¨æ©Ÿå­˜å–ï¼Œä½†å…¶è¨˜æ†¶é«”ä¸æ˜¯é€£çºŒé…ç½®ï¼Œä¸é©ç”¨æ–¼éœ€è¦åŸå§‹æŒ‡æ¨™çš„å‡½å¼ï¼ˆå¦‚ `memcpy`ï¼‰ã€‚
    
- ç›¸æ¯” `vector`ï¼Œä¸ä¿è­‰ cache localityï¼ˆè¨˜æ†¶é«”é€£çºŒæ€§ï¼‰ï¼Œå°æŸäº›æ‡‰ç”¨æ•ˆèƒ½ç•¥å·®ã€‚
    

---
## ğŸ”— `std::list` â€” é›™å‘éˆçµä¸²åˆ—å®¹å™¨ï¼ˆDoubly Linked Listï¼‰

### ğŸ“˜ æ¦‚è¦

`std::list` æ˜¯ä¸€ç¨®**é›™å‘éˆçµä¸²åˆ—**ï¼Œæ¯å€‹ç¯€é»åŒ…å«è³‡æ–™èˆ‡å‰å¾ŒæŒ‡æ¨™ï¼Œå…è¨±åœ¨ä»»ä½•ä½ç½®**å¸¸æ•¸æ™‚é–“æ’å…¥èˆ‡åˆªé™¤**ã€‚  
å®ƒä¸æ”¯æ´éš¨æ©Ÿå­˜å–ï¼ˆç„¡æ³•ç”¨ `[]` ä¾†è¨ªå•ç¬¬ i å€‹å…ƒç´ ï¼‰ã€‚

### ğŸ§± å…§éƒ¨å¯¦ä½œ

æ¯å€‹å…ƒç´ ï¼ˆç¯€é»ï¼‰éƒ½æœ‰æŒ‡å‘å‰ä¸€å€‹èˆ‡ä¸‹ä¸€å€‹å…ƒç´ çš„æŒ‡æ¨™ï¼Œä¾¿æ–¼é›™å‘èµ°è¨ªèˆ‡ä¿®æ”¹ã€‚ä¸åŒæ–¼ `vector` æˆ– `deque`ï¼Œå…¶å…ƒç´ **ä¸é€£çºŒé…ç½®**ã€‚

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³•|èªªæ˜|
|---|---|
|`list<T> lst;`|å»ºç«‹ç©ºçš„ list|
|`lst.push_back(val);`|åœ¨å°¾ç«¯æ’å…¥å…ƒç´ |
|`lst.push_front(val);`|åœ¨å‰ç«¯æ’å…¥å…ƒç´ |
|`lst.pop_back();` / `lst.pop_front();`|ç§»é™¤å°¾ç«¯ / å‰ç«¯å…ƒç´ |
|`lst.front();` / `lst.back();`|å­˜å–æœ€å‰ / æœ€å¾Œå…ƒç´ |
|`lst.insert(pos, val);`|æ’å…¥å…ƒç´ åˆ°æŒ‡å®š iterator å‰|
|`lst.erase(pos);`|ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´ |
|`lst.begin(), lst.end()`|Iterator èµ·è¿„ä½ç½®|
|`lst.rbegin(), lst.rend()`|åå‘ iterator|
|`lst.sort();`|å°±åœ°æ’åºï¼ˆç”¨ operator<ï¼‰|
|`lst.reverse();`|åè½‰å…ƒç´ é †åº|
|`lst.remove(val);`|ç§»é™¤æ‰€æœ‰èˆ‡ `val` ç›¸ç­‰çš„å…ƒç´ |
|`lst.unique();`|ç§»é™¤é€£çºŒé‡è¤‡å…ƒç´ ï¼ˆæ’åºå¾Œä½¿ç”¨ï¼‰|
|`lst.merge(otherList);`|åˆä½µå·²æ’åºçš„å…©å€‹ list|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst;

    // æ’å…¥å…ƒç´ 
    lst.push_back(10);
    lst.push_front(5);
    lst.push_back(20);

    std::cout << "ç›®å‰å…§å®¹: ";
    for (int x : lst)
        std::cout << x << " ";
    std::cout << '\n';

    // æ’å…¥åœ¨ç¬¬äºŒå€‹ä½ç½®
    auto it = lst.begin();
    ++it; // ç§»åˆ°ç¬¬äºŒå€‹å…ƒç´ 
    lst.insert(it, 99); // æ’åœ¨ 10 å‰é¢

    std::cout << "æ’å…¥å¾Œ: ";
    for (int x : lst)
        std::cout << x << " ";
    std::cout << '\n';

    // æ’åºèˆ‡åè½‰
    lst.sort();
    lst.reverse();

    std::cout << "æ’åºåè½‰å¾Œ: ";
    for (int x : lst)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- ç¶“å¸¸éœ€è¦åœ¨**ä¸­é–“æ’å…¥æˆ–åˆªé™¤å…ƒç´ **çš„å ´æ™¯
    
- è³‡æ–™é‡å¤§ã€æ’åºèˆ‡å»é‡éœ€æ±‚å¤šï¼ˆæ­é… `sort()` èˆ‡ `unique()`ï¼‰
    

### âš ï¸ æ³¨æ„äº‹é …

- ç„¡æ³•é€é `lst[i]` è¨ªå•ç‰¹å®šä½ç½®ï¼ˆåªèƒ½ä½¿ç”¨ iterator æ…¢æ…¢èµ°ï¼‰
    
- ç›¸æ¯” `vector`ï¼Œ**æ¯å€‹ç¯€é»é¡å¤–å¤šä½”å…©å€‹æŒ‡æ¨™ç©ºé–“**
    
- ç„¡æ³•èˆ‡ C-style APIï¼ˆå¦‚ `memcpy`ï¼‰é…åˆ
    

---
## ğŸ§µ `std::forward_list` â€” å–®å‘éˆçµä¸²åˆ—å®¹å™¨ï¼ˆSingly Linked Listï¼‰

### ğŸ“˜ æ¦‚è¦

`std::forward_list` æ˜¯ä¸€ç¨®**å–®å‘éˆçµä¸²åˆ—**ï¼Œæ¯å€‹ç¯€é»åªæœ‰ä¸€å€‹æŒ‡å‘ã€Œä¸‹ä¸€å€‹ç¯€é»ã€çš„æŒ‡æ¨™ã€‚å®ƒæ˜¯ C++11 æ–°å¢çš„å®¹å™¨ï¼Œè¨­è¨ˆç›®çš„æ˜¯ç‚ºäº†**ç¯€çœè¨˜æ†¶é«”ç©ºé–“**èˆ‡æé«˜æŸäº›å ´æ™¯ä¸‹çš„æ•ˆç‡ã€‚

### ğŸ§± å…§éƒ¨å¯¦ä½œ

æ¯å€‹å…ƒç´ åªæŒæœ‰ `next` æŒ‡æ¨™ï¼ˆä¸åƒ `list` æœ‰ `prev` å’Œ `next`ï¼‰ï¼Œä¸æ”¯æ´å°¾ç«¯æ“ä½œï¼Œä¹Ÿä¸æ”¯æ´é›™å‘èµ°è¨ªã€‚

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³•|èªªæ˜|
|---|---|
|`forward_list<T> fl;`|å»ºç«‹ç©ºçš„ forward_list|
|`fl.push_front(val);`|åŠ å…¥å…ƒç´ åˆ°å‰ç«¯|
|`fl.pop_front();`|ç§»é™¤å‰ç«¯å…ƒç´ |
|`fl.front();`|å–å‡ºæœ€å‰ç«¯å…ƒç´ |
|`fl.insert_after(pos, val);`|åœ¨ `pos` å¾Œæ’å…¥å…ƒç´ |
|`fl.erase_after(pos);`|ç§»é™¤ `pos` å¾Œçš„å…ƒç´ |
|`fl.before_begin()`|ç‰¹æ®Š iteratorï¼šç”¨æ–¼æ’å…¥ç¬¬ä¸€å€‹å…ƒç´ ä¹‹å‰|
|`fl.begin(), fl.end()`|æ­£å¸¸èµ°è¨ªç”¨|
|`fl.sort();`|æ’åºå…ƒç´ |
|`fl.reverse();`|åè½‰å…ƒç´ é †åº|
|`fl.remove(val);`|ç§»é™¤æ‰€æœ‰èˆ‡ val ç›¸ç­‰çš„å…ƒç´ |
|`fl.unique();`|ç§»é™¤é€£çºŒé‡è¤‡å…ƒç´ |
|`fl.merge(other);`|åˆä½µå·²æ’åºçš„ forward_list|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> fl = {3, 6, 9};

    // åœ¨å‰é¢æ’å…¥
    fl.push_front(1);  // [1, 3, 6, 9]

    // æ’å…¥åœ¨ç¬¬ä¸€å€‹å…ƒç´ å¾Œ
    auto it = fl.begin(); // æŒ‡å‘ 1
    fl.insert_after(it, 2);  // [1, 2, 3, 6, 9]

    // ç§»é™¤æŸå€‹å…ƒç´ å¾Œçš„ç¯€é»
    fl.erase_after(it); // [1, 2, 6, 9]

    // éæ­·
    std::cout << "å…§å®¹: ";
    for (int x : fl)
        std::cout << x << " ";
    std::cout << '\n';

    // æ’åºèˆ‡åè½‰
    fl.sort();
    fl.reverse();

    std::cout << "æ’åºåè½‰å¾Œ: ";
    for (int x : fl)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- ç¯€çœè¨˜æ†¶é«”ç©ºé–“ï¼ˆæ¯” `list` å°‘ä¸€å€‹æŒ‡æ¨™ï¼‰
    
- é »ç¹é€²è¡Œ**å‰ç«¯æ’å…¥æˆ–åˆªé™¤**
    
- åªéœ€è¦**å–®å‘èµ°è¨ª**
    

### âš ï¸ æ³¨æ„äº‹é …

- æ²’æœ‰ `push_back()` æˆ– `pop_back()`ï¼ˆåªèƒ½æ“ä½œå‰ç«¯ï¼‰
    
- æ²’æœ‰ `size()` æˆå“¡å‡½å¼ï¼ˆä½ è¦æ‰‹å‹•è¨ˆç®—ï¼‰
    
- æ’å…¥åˆªé™¤æ™‚éœ€ä½¿ç”¨ `insert_after` / `erase_after`ï¼Œç¨å¾®ä¸ç›´è¦º
    
- iterator ç„¡æ³•å€’é€€ï¼ˆä¸åƒ `list` æœ‰ bidirectional iteratorï¼‰
    

---
## ğŸ“ `std::array` â€” å›ºå®šå¤§å°çš„éœæ…‹é™£åˆ—å®¹å™¨ï¼ˆC++11 èµ·ï¼‰

### ğŸ“˜ æ¦‚è¦

`std::array` æ˜¯ä¸€ç¨® **å›ºå®šå¤§å°ã€éœæ…‹é…ç½®** çš„å®¹å™¨ï¼Œæä¾› C-style é™£åˆ—çš„è¨˜æ†¶é«”æ•ˆç‡èˆ‡ STL å®¹å™¨çš„ä»‹é¢ã€‚  
å¤§å°å¿…é ˆåœ¨**ç·¨è­¯æœŸé–“**æ±ºå®šï¼Œä¸èƒ½å‹•æ…‹èª¿æ•´ã€‚

```cpp
#include <array>
std::array<int, 5> arr;  // å®£å‘Šä¸€å€‹æœ‰ 5 å€‹ int çš„ array
```

### ğŸ§± å…§éƒ¨å¯¦ä½œ

æœ¬è³ªä¸Šå°±æ˜¯åŒ…è£ C-style é™£åˆ— (`T[N]`) ä¸¦æä¾›ï¼š

- STL ç›¸å®¹çš„ iterator
    
- æˆå“¡å‡½å¼ï¼ˆå¦‚ `at()`ã€`size()`ï¼‰
    
- æ‹·è²èˆ‡è³¦å€¼æ“ä½œï¼ˆå®Œæ•´ value semanticsï¼‰
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`array<T, N>`|å®£å‘Šå›ºå®šå¤§å°ç‚º `N` çš„é™£åˆ—|
|`a[i] / a.at(i)`|å­˜å–ç¬¬ `i` å€‹å…ƒç´ ï¼›`at()` æœƒæª¢æŸ¥è¶Šç•Œ|
|`a.front()` / `a.back()`|å­˜å–ç¬¬ä¸€æˆ–æœ€å¾Œä¸€å€‹å…ƒç´ |
|`a.fill(val)`|å°‡æ‰€æœ‰å…ƒç´ è¨­ç‚º `val`|
|`a.size()`|å‚³å›å…ƒç´ å€‹æ•¸ï¼ˆæ°¸é æ˜¯ Nï¼‰|
|`a.begin()` / `a.end()`|iterator èµ·è¿„ä½ç½®|
|`a.data()`|å‚³å›åº•å±¤åŸå§‹é™£åˆ—æŒ‡æ¨™ `T*`ï¼ˆå¯èˆ‡ C API äº’é€šï¼‰|
|`a.swap(b)`|èˆ‡å¦ä¸€å€‹åŒå‹åˆ¥ `array` äº¤æ›å…§å®¹|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    // è¨ªå•å…ƒç´ 
    std::cout << "ç¬¬ä¸€å€‹å…ƒç´ : " << arr.front() << '\n';
    std::cout << "æœ€å¾Œä¸€å€‹å…ƒç´ : " << arr.back() << '\n';

    // æ”¹è®Šå…§å®¹
    arr[2] = 99;

    // ä½¿ç”¨ç¯„åœ for loop
    std::cout << "æ‰€æœ‰å…§å®¹: ";
    for (int x : arr)
        std::cout << x << " ";
    std::cout << '\n';

    // ä½¿ç”¨ fill()
    arr.fill(0);
    std::cout << "å…¨éƒ¨æ¸…ç‚º 0: ";
    for (int x : arr)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- å·²çŸ¥å¤§å°ä¸”ä¸éœ€è®Šå‹•çš„åºåˆ—è³‡æ–™ï¼ˆä¾‹å¦‚ RGBã€åº§æ¨™ã€å›ºå®šå¤§å°è¡¨æ ¼ç­‰ï¼‰
    
- C-style é™£åˆ—éœ€è¦å®‰å…¨å°è£èˆ‡ STL ç›¸å®¹ä»‹é¢
    
- æ­é… template ç”¨æ–¼ç·¨è­¯æœŸæœ€ä½³åŒ–å ´æ™¯ï¼ˆéœæ…‹é…ç½®æ›´å¿«ï¼‰


### âš ï¸ æ³¨æ„äº‹é …

- **å¤§å°å›ºå®šï¼Œä¸å¯æ“´å¼µ**ï¼Œå¦å‰‡è«‹ç”¨ `vector`
    
- å…ƒç´ æ•¸é‡éœ€æ–¼ **ç·¨è­¯æ™‚æŒ‡å®š**
    
- é›–ç‚º STL å®¹å™¨ï¼Œä½†ä¸æ˜¯å‹•æ…‹è³‡æ–™çµæ§‹ï¼ˆä¸å«è¨˜æ†¶é«”ç®¡ç†é‚è¼¯ï¼‰
    

---

# ğŸ” **Associative Containersï¼ˆé—œè¯å¼å®¹å™¨ï¼‰**

## ğŸŒ² `std::set` â€” å”¯ä¸€ä¸”è‡ªå‹•æ’åºçš„é›†åˆå®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::set` æ˜¯ä¸€å€‹**é—œè¯å¼å®¹å™¨**ï¼Œç”¨ä¾†å„²å­˜**å”¯ä¸€å…ƒç´ **ï¼Œä¸”æœƒæ ¹æ“šå…ƒç´ å¤§å°**è‡ªå‹•æ’åºï¼ˆé è¨­ç”¨ `operator<`ï¼‰**ã€‚  
å…¶åº•å±¤æ˜¯ **ç´…é»‘æ¨¹ï¼ˆRed-Black Treeï¼‰**ï¼Œæ‰€ä»¥æ‰€æœ‰æ“ä½œæ™‚é–“è¤‡é›œåº¦çš†ç‚º O(logâ€¯n)ã€‚

```cpp
#include <set>
std::set<int> s;
```

### ğŸ§± å…§éƒ¨çµæ§‹

- ä½¿ç”¨**å¹³è¡¡äºŒå…ƒæœå°‹æ¨¹**ç¶­æŒæ’åºï¼ˆé€šå¸¸ç‚ºç´…é»‘æ¨¹ï¼‰
    
- æ’å…¥èˆ‡æŸ¥æ‰¾çš†ç‚º O(logâ€¯n)
    
- æ‰€æœ‰å…ƒç´ çš†è¦–ç‚ºã€Œkeyã€ï¼Œå› æ­¤ä¸å¯é‡è¤‡ï¼ˆ`==` çš„å…ƒç´ åªèƒ½å‡ºç¾ä¸€æ¬¡ï¼‰
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`s.insert(val)`|æ’å…¥å…ƒç´ ï¼Œè‹¥å·²å­˜åœ¨å‰‡å¿½ç•¥|
|`s.erase(val)`|ç§»é™¤æŒ‡å®šå€¼çš„å…ƒç´ |
|`s.erase(it)`|ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´ |
|`s.find(val)`|å›å‚³æŒ‡å‘è©²å€¼çš„ iteratorï¼Œè‹¥ä¸å­˜åœ¨å‰‡ç‚º `end()`|
|`s.count(val)`|å›å‚³è©²å€¼çš„å‡ºç¾æ¬¡æ•¸ï¼ˆå° `set` è€Œè¨€ç‚º 0 æˆ– 1ï¼‰|
|`s.lower_bound(val)`|å›å‚³ç¬¬ä¸€å€‹ â‰¥ val çš„ iterator|
|`s.upper_bound(val)`|å›å‚³ç¬¬ä¸€å€‹ > val çš„ iterator|
|`s.begin(), s.end()`|å–å¾—æ­£å‘ iterator|
|`s.rbegin(), s.rend()`|å–å¾—åå‘ iterator|
|`s.empty()` / `s.size()`|æ˜¯å¦ç‚ºç©ºã€å…ƒç´ æ•¸é‡|
|`s.clear()`|æ¸…ç©ºé›†åˆ|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;

    // æ’å…¥å…ƒç´ 
    s.insert(3);
    s.insert(1);
    s.insert(4);
    s.insert(1); // é‡è¤‡å…ƒç´ è¢«å¿½ç•¥

    std::cout << "æ’åºå¾Œå…§å®¹: ";
    for (int x : s)
        std::cout << x << " ";
    std::cout << '\n';  // 1 3 4

    // æŸ¥æ‰¾
    if (s.count(3))
        std::cout << "æ‰¾åˆ° 3\n";

    // ä½¿ç”¨ lower_bound / upper_bound
    auto it = s.lower_bound(2); // >= 2 çš„ç¬¬ä¸€å€‹
    if (it != s.end())
        std::cout << "ç¬¬ä¸€å€‹ â‰¥ 2 çš„å…ƒç´ æ˜¯: " << *it << '\n';

    // ç§»é™¤å…ƒç´ 
    s.erase(3);

    std::cout << "ç§»é™¤å¾Œå…§å®¹: ";
    for (int x : s)
        std::cout << x << " ";
}
```

### ğŸ§  é—œæ–¼ `insert` å›å‚³å€¼

```cpp
auto result = s.insert(10);
if (result.second) {
    std::cout << "æ’å…¥æˆåŠŸï¼ä½ç½®ï¼š" << *result.first << '\n';
} else {
    std::cout << "å·²å­˜åœ¨æ–¼ set ä¸­\n";
}
```

- `insert()` å›å‚³ `pair<iterator, bool>`ï¼Œç¬¬äºŒå€‹å€¼ä»£è¡¨æ˜¯å¦çœŸçš„æ’å…¥æˆåŠŸã€‚
    

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦ç¶­æŒå…ƒç´ **å”¯ä¸€æ€§èˆ‡è‡ªå‹•æ’åº**
    
- æŸ¥æ‰¾ã€æ’å…¥ã€åˆªé™¤æ•ˆç‡è¦æ±‚ O(logâ€¯n)
    
- å¯ç•¶ä½œ**å»é‡éçš„æ’åºé›†åˆ**ï¼ˆå¦‚çµ±è¨ˆç¨ç‰¹è¼¸å…¥ã€å­—å…¸ã€ç´¢å¼•ç­‰ï¼‰
    

### âš ï¸ æ³¨æ„äº‹é …

- ä¸æ”¯æ´ `operator[]`ï¼ˆå› ç‚ºæ²’æœ‰ value çš„æ¦‚å¿µï¼‰
    
- æ’å…¥ç›¸åŒå…ƒç´ ä¸æœƒè¦†è“‹ä¹Ÿä¸æœƒå ±éŒ¯ï¼Œåªæ˜¯å¿½ç•¥
    
- è‹¥éœ€å„²å­˜é‡è¤‡å…ƒç´ ï¼Œè«‹æ”¹ç”¨ `multiset`
    

---
## ğŸŒ¿ `std::multiset` â€” å…è¨±é‡è¤‡å…ƒç´ çš„æ’åºé›†åˆ

### ğŸ“˜ æ¦‚è¦

`std::multiset` å’Œ `std::set` å¹¾ä¹ä¸€æ¨¡ä¸€æ¨£ï¼Œå”¯ä¸€çš„å·®åˆ¥æ˜¯å®ƒ**å…è¨±å¤šå€‹é‡è¤‡çš„å…ƒç´ **ã€‚  
åº•å±¤ä¸€æ¨£ä½¿ç”¨ **ç´…é»‘æ¨¹ï¼ˆRed-Black Treeï¼‰**ï¼Œæ“ä½œæ•ˆç‡ç‚º O(logâ€¯n)ã€‚

```cpp
#include <set>
std::multiset<int> ms;
```

### ğŸ§± å…§éƒ¨çµæ§‹

- å…ƒç´ è‡ªå‹•æ’åºï¼ˆä½¿ç”¨ `operator<`ï¼‰
    
- æ¯å€‹å…ƒç´ è¦–ç‚º keyï¼Œå¯é‡è¤‡
    
- è³‡æ–™çµæ§‹ç‚ºè‡ªå‹•å¹³è¡¡çš„æœå°‹æ¨¹ï¼Œæ’å…¥èˆ‡åˆªé™¤çš†ç‚º O(logâ€¯n)
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`ms.insert(val)`|æ’å…¥å…ƒç´ ï¼ˆå…è¨±é‡è¤‡ï¼‰|
|`ms.erase(val)`|ç§»é™¤æ‰€æœ‰è©²å€¼çš„å…ƒç´ |
|`ms.erase(it)`|ç§»é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ |
|`ms.find(val)`|å›å‚³ç¬¬ä¸€å€‹ç­‰æ–¼è©²å€¼çš„ iterator|
|`ms.count(val)`|å›å‚³è©²å€¼å‡ºç¾çš„æ¬¡æ•¸|
|`ms.lower_bound(val)`|ç¬¬ä¸€å€‹ â‰¥ val çš„ iterator|
|`ms.upper_bound(val)`|ç¬¬ä¸€å€‹ > val çš„ iterator|
|`ms.equal_range(val)`|å›å‚³ `pair<lower_bound, upper_bound>` ç¯„åœ|
|`ms.begin(), ms.end()`|æ­£å‘ iterator|
|`ms.rbegin(), ms.rend()`|åå‘ iterator|
|`ms.empty()` / `ms.size()`|æ˜¯å¦ç‚ºç©ºã€å…ƒç´ å€‹æ•¸|
|`ms.clear()`|æ¸…ç©ºå®¹å™¨|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> ms;

    // æ’å…¥å…ƒç´ 
    ms.insert(10);
    ms.insert(20);
    ms.insert(10);  // é‡è¤‡æ’å…¥
    ms.insert(30);

    std::cout << "å…§å®¹: ";
    for (int x : ms)
        std::cout << x << " ";
    std::cout << '\n'; // è¼¸å‡º: 10 10 20 30

    // æŸ¥æ‰¾æŸå…ƒç´ çš„æ¬¡æ•¸
    std::cout << "10 å‡ºç¾æ¬¡æ•¸: " << ms.count(10) << '\n';

    // ä½¿ç”¨ equal_range
    auto [begin, end] = ms.equal_range(10);
    std::cout << "10 çš„ç¯„åœ: ";
    for (auto it = begin; it != end; ++it)
        std::cout << *it << " ";
    std::cout << '\n';

    // ç§»é™¤å–®ä¸€å€‹ 10
    auto it = ms.find(10);
    if (it != ms.end())
        ms.erase(it);  // åªåˆªæ‰ä¸€å€‹ 10

    std::cout << "åˆªé™¤ä¸€å€‹ 10 å¾Œ: ";
    for (int x : ms)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦å„²å­˜é‡è¤‡å…ƒç´ ä¸¦ä¸”**ç¶­æŒè‡ªå‹•æ’åº**
    
- çµ±è¨ˆå‡ºç¾æ¬¡æ•¸ã€ç¶­è­·æœ‰åºè³‡æ–™ï¼ˆä¾‹å¦‚ï¼šå¤šç­†æˆç¸¾ã€åŒåˆ†è€…æ’åºï¼‰
    
- èˆ‡ `map` æ­é…å¯å¯¦ä½œ multimap åŠŸèƒ½çš„éµé›†åˆ
    

### âš ï¸ æ³¨æ„äº‹é …

- **æ’å…¥çš„æ‰€æœ‰å…ƒç´ çš†æœƒä¿ç•™**ï¼Œä¸æœƒå»é‡
    
- `erase(val)` æœƒåˆªé™¤**æ‰€æœ‰**è©²å€¼ï¼Œè‹¥åªæƒ³åˆªä¸€å€‹éœ€ç”¨ `find()` + `erase(it)`
    
- æ²’æœ‰ `operator[]`
    

---
## ğŸ“‘ `std::map` â€” å”¯ä¸€éµçš„é—œè¯å¼éµå€¼å°å®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::map` æ˜¯ä¸€å€‹å„²å­˜**éµå€¼å°ï¼ˆkey-value pairsï¼‰**çš„é—œè¯å¼å®¹å™¨ï¼Œ  
æœƒæ ¹æ“š key è‡ªå‹•æ’åºï¼Œä¸¦ä¿è­‰æ¯å€‹ key **å”¯ä¸€ä¸”åƒ…å‡ºç¾ä¸€æ¬¡**ã€‚  
åº•å±¤ä½¿ç”¨ **ç´…é»‘æ¨¹ï¼ˆRed-Black Treeï¼‰**ï¼Œæ”¯æ´ O(logâ€¯n) æ’å…¥ã€åˆªé™¤èˆ‡æŸ¥æ‰¾ã€‚

```cpp
#include <map>
std::map<std::string, int> age;
```

### ğŸ§± è³‡æ–™çµæ§‹èˆ‡ `pair`

æ¯å€‹å…ƒç´ æ˜¯ `std::pair<const Key, T>`ï¼Œä¾‹å¦‚ï¼š

```cpp
std::map<std::string, int> m;
m["Alice"] = 30;  // æ’å…¥ pair<const string, int>("Alice", 30)
```

- `key` æ˜¯ç¬¬ä¸€å€‹æˆå“¡ï¼ˆä¸å¯é‡è¤‡ï¼‰
    
- `value` æ˜¯ç¬¬äºŒå€‹æˆå“¡ï¼ˆå¯ä¿®æ”¹ï¼‰
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`m[key] = val`|æ’å…¥æˆ–æ›´æ–° `key` å°æ‡‰çš„å€¼|
|`m.at(key)`|å­˜å–å€¼ï¼Œè‹¥ key ä¸å­˜åœ¨æœƒæ‹‹å‡ºä¾‹å¤–|
|`m.insert({key, val})`|æ’å…¥æ–°çš„éµå€¼å°ï¼ˆè‹¥ key å·²å­˜åœ¨å‰‡ç„¡æ•ˆï¼‰|
|`m.emplace(key, val)`|åŸåœ°å»ºæ§‹éµå€¼å°ï¼ˆæ•ˆç‡æ›´é«˜ï¼‰|
|`m.find(key)`|å›å‚³ iterator æŒ‡å‘è©² keyï¼Œæˆ– `end()`|
|`m.count(key)`|å›å‚³è©² key æ˜¯å¦å­˜åœ¨ï¼ˆç‚º 0 æˆ– 1ï¼‰|
|`m.erase(key)` / `m.erase(it)`|ç§»é™¤å…ƒç´ ï¼ˆé€é key æˆ– iteratorï¼‰|
|`m.lower_bound(key)`|ç¬¬ä¸€å€‹ â‰¥ key çš„å…ƒç´  iterator|
|`m.upper_bound(key)`|ç¬¬ä¸€å€‹ > key çš„å…ƒç´  iterator|
|`m.begin(), m.end()`|iterator èµ·è¿„ä½ç½®ï¼ˆç…§ key æ’åºï¼‰|
|`m.empty()` / `m.size()` / `m.clear()`|é€šç”¨æˆå“¡å‡½å¼|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> scores;

    // æ’å…¥èˆ‡æ›´æ–°
    scores["Alice"] = 95;
    scores["Bob"] = 89;
    scores["Charlie"] = 77;

    // æ›´æ–° Bob çš„åˆ†æ•¸
    scores["Bob"] = 92;

    // ä½¿ç”¨è¿´åœˆè¼¸å‡º
    for (const auto& [name, score] : scores)
        std::cout << name << ": " << score << '\n';

    // æŸ¥æ‰¾ç‰¹å®š key
    if (scores.count("Alice"))
        std::cout << "Alice çš„åˆ†æ•¸æ˜¯ " << scores.at("Alice") << '\n';

    // ç§»é™¤ Charlie
    scores.erase("Charlie");

    std::cout << "ç›®å‰å‰©ä¸‹ " << scores.size() << " ç­†è³‡æ–™ã€‚\n";
}
```

### ğŸ§  é—œæ–¼ `m[key]` çš„éš±å«è¡Œç‚º

```cpp
std::map<std::string, int> m;
std::cout << m["nonexistent"] << '\n';  // â—æœƒè‡ªå‹•æ’å…¥ "nonexistent": 0
```

ä½¿ç”¨ `[]` å­˜å–ä¸å­˜åœ¨çš„ keyï¼Œ**æœƒè‡ªå‹•æ’å…¥è©² key ä¸¦çµ¦ä¸€å€‹é è¨­å€¼**ã€‚  
è‹¥ä¸æƒ³è‡ªå‹•æ’å…¥ï¼Œè«‹ä½¿ç”¨ `find()` æˆ– `at()`ã€‚

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éµå€¼å”¯ä¸€ã€éœ€è‡ªå‹•æ’åºçš„è³‡æ–™ï¼ˆä¾‹å¦‚ï¼šçµ±è¨ˆå­—é »ã€æŸ¥è©¢ ID å°æ‡‰è³‡è¨Šï¼‰
    
- éœ€è¦é«˜æ•ˆ O(logâ€¯n) æŸ¥æ‰¾èˆ‡æ’å…¥
    
- å¯ç”¨ä¾†æ¨¡æ“¬ã€Œdictionaryã€ã€ã€Œsymbol tableã€ã€ã€Œphonebookã€ç­‰çµæ§‹
    

### âš ï¸ æ³¨æ„äº‹é …

- è‹¥éœ€å„²å­˜é‡è¤‡ keyï¼Œè«‹ä½¿ç”¨ `multimap`
    
- è‹¥ä¸éœ€è¦æ’åºï¼Œè¿½æ±‚æ›´å¿«æ•ˆç‡ï¼Œå¯æ”¹ç”¨ `unordered_map`
    
- ä½¿ç”¨ `operator[]` æ™‚è¦ç•™æ„ã€Œ**ä¸å°å¿ƒæ’å…¥ä¸è©²æœ‰çš„ key**ã€å•é¡Œ
    
---
## ğŸ“š `std::multimap` â€” å…è¨±é‡è¤‡éµçš„é—œè¯å¼éµå€¼å°å®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::multimap` èˆ‡ `std::map` é¡ä¼¼ï¼Œéƒ½æ˜¯å„²å­˜**éµå€¼å°ï¼ˆkey-value pairsï¼‰**ï¼Œä½†å…è¨±å¤šå€‹å…ƒç´ æ“æœ‰ç›¸åŒçš„ keyã€‚  
åº•å±¤ä¸€æ¨£ä½¿ç”¨å¹³è¡¡äºŒå…ƒæœå°‹æ¨¹ï¼ˆé€šå¸¸æ˜¯ç´…é»‘æ¨¹ï¼‰ï¼Œæ‰€ä»¥æ’å…¥ã€æŸ¥æ‰¾ã€åˆªé™¤çš„æ™‚é–“è¤‡é›œåº¦å‡ç‚º O(logâ€¯n)ã€‚

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`mm.insert({key, val})`|æ’å…¥å…ƒç´ ï¼Œå…è¨±é‡è¤‡éµ|
|`mm.emplace(key, val)`|åŸåœ°å»ºæ§‹æ’å…¥å…ƒç´ |
|`mm.erase(key)`|ç§»é™¤æ‰€æœ‰åŒ¹é… key çš„å…ƒç´ |
|`mm.erase(it)`|ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´ |
|`mm.find(key)`|æ‰¾åˆ°ç¬¬ä¸€å€‹åŒ¹é… key çš„ iterator|
|`mm.count(key)`|å›å‚³è©² key å‡ºç¾çš„æ¬¡æ•¸|
|`mm.lower_bound(key)`|ç¬¬ä¸€å€‹ â‰¥ key çš„ iterator|
|`mm.upper_bound(key)`|ç¬¬ä¸€å€‹ > key çš„ iterator|
|`mm.equal_range(key)`|å›å‚³ pair(lower_bound, upper_bound)|
|`mm.begin(), mm.end()`|æ­£å‘ iterator|
|`mm.rbegin(), mm.rend()`|åå‘ iterator|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::multimap<std::string, int> mm;

    mm.insert({"Alice", 90});
    mm.insert({"Bob", 85});
    mm.insert({"Alice", 95});  // é‡è¤‡éµ

    std::cout << "å…§å®¹:\n";
    for (const auto& [name, score] : mm) {
        std::cout << name << ": " << score << '\n';
    }

    // æŸ¥è©¢ Alice çš„æ‰€æœ‰åˆ†æ•¸
    auto range = mm.equal_range("Alice");
    std::cout << "Alice çš„åˆ†æ•¸:\n";
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << it->second << '\n';
    }

    // åˆªé™¤æ‰€æœ‰ Bob
    mm.erase("Bob");

    std::cout << "åˆªé™¤ Bob å¾Œå…§å®¹:\n";
    for (const auto& [name, score] : mm) {
        std::cout << name << ": " << score << '\n';
    }
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦åŒä¸€ key å°æ‡‰å¤šå€‹ value çš„æƒ…æ³ï¼ˆä¾‹å¦‚ï¼šåˆ†é¡è³‡æ–™ã€å¤šç­†äº¤æ˜“è¨˜éŒ„ï¼‰
    
- éœ€è¦æ’åºä¸”å…è¨±é‡è¤‡éµçš„é—œè¯è³‡æ–™å„²å­˜
    

### âš ï¸ æ³¨æ„äº‹é …

- ä¸æ”¯æ´ç”¨ `operator[]`ï¼ˆå› ç‚º key å¯é‡è¤‡ï¼Œç„¡æ³•å”¯ä¸€ç´¢å¼•ï¼‰
    
- `erase(key)` æœƒåˆªé™¤æ‰€æœ‰åŒ¹é…çš„å…ƒç´ 
    
- æ’å…¥æ™‚ä¸æœƒè¦†è“‹ç¾æœ‰è³‡æ–™

---
# ğŸŒªï¸ **Unordered Containersï¼ˆéæ’åºé—œè¯å¼å®¹å™¨ï¼‰**

## âš¡ `std::unordered_set` â€” å”¯ä¸€å…ƒç´ çš„å“ˆå¸Œé›†åˆå®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::unordered_set` æ˜¯ä¸€ç¨®åŸºæ–¼**å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰**å¯¦ä½œçš„é›†åˆå®¹å™¨ï¼Œ  
ç”¨ä¾†å„²å­˜**å”¯ä¸€å…ƒç´ **ï¼Œä½†å…ƒç´ **ä¸æœƒè‡ªå‹•æ’åº**ï¼Œè€Œæ˜¯ä¾ç…§å“ˆå¸Œå€¼åˆ†ä½ˆã€‚  
æŸ¥æ‰¾ã€æ’å…¥ã€åˆªé™¤çš„å¹³å‡æ™‚é–“è¤‡é›œåº¦æ¥è¿‘ O(1)ã€‚

### ğŸ§± å…§éƒ¨çµæ§‹

- ä½¿ç”¨å“ˆå¸Œå‡½å¼ (`std::hash<T>`) ä¾†è¨ˆç®—å…ƒç´ ä½ç½®
    
- é€ééˆçµæ³•æˆ–é–‹æ”¾ä½å€æ³•è§£æ±ºå“ˆå¸Œç¢°æ’
    
- ä¸ä¿è­‰å…ƒç´ çš„éæ­·é †åºï¼Œæ¯æ¬¡åŸ·è¡Œå¯èƒ½ä¸åŒ
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`us.insert(val)`|æ’å…¥å…ƒç´ ï¼Œé‡è¤‡å…ƒç´ æœƒè¢«å¿½ç•¥|
|`us.erase(val)`|ç§»é™¤æŒ‡å®šå…ƒç´ |
|`us.find(val)`|æŸ¥æ‰¾å…ƒç´ ï¼Œå›å‚³ iterator æˆ– `end()`|
|`us.count(val)`|å›å‚³å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼ˆ0 æˆ– 1ï¼‰|
|`us.bucket_count()`|ç²å–æ¡¶æ•¸ï¼ˆhash table sizeï¼‰|
|`us.load_factor()`|è¼‰å…¥å› å­ï¼Œè¡¡é‡å¡«å……ç¨‹åº¦|
|`us.rehash(n)`|é‡æ–°é…ç½®æ¡¶æ•¸ï¼Œè‡³å°‘ç‚º n|
|`us.begin(), us.end()`|è¿­ä»£å™¨|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> us;

    us.insert(10);
    us.insert(20);
    us.insert(10);  // é‡è¤‡æœƒè¢«å¿½ç•¥

    std::cout << "å…§å®¹: ";
    for (int x : us)
        std::cout << x << " ";
    std::cout << '\n';

    if (us.count(20))
        std::cout << "20 å­˜åœ¨æ–¼é›†åˆä¸­\n";

    us.erase(10);
    std::cout << "åˆªé™¤ 10 å¾Œå…§å®¹: ";
    for (int x : us)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- åªé—œå¿ƒå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œä¸éœ€æ’åº
    
- è¿½æ±‚å¿«é€Ÿæ’å…¥èˆ‡æŸ¥æ‰¾ï¼ˆå¹³å‡ O(1)ï¼‰
    
- å…ƒç´ é¡å‹å¿…é ˆå¯ç”¨æ–¼å“ˆå¸Œï¼ˆæ¨™æº–é¡å‹éƒ½æ”¯æ´ï¼‰
    

### âš ï¸ æ³¨æ„äº‹é …

- ä¸ä¿è­‰éæ­·é †åº
    
- å“ˆå¸Œå‡½å¼è¡çªæœƒå½±éŸ¿æ•ˆèƒ½
    
- éœ€è¦åˆé©çš„å“ˆå¸Œå‡½å¼èˆ‡ç›¸ç­‰æ¯”è¼ƒå™¨

	
---
## âš¡ `std::unordered_multiset` â€” å…è¨±é‡è¤‡å…ƒç´ çš„å“ˆå¸Œé›†åˆ

### ğŸ“˜ æ¦‚è¦

`std::unordered_multiset` å’Œ `unordered_set` é¡ä¼¼ï¼Œ  
ä½†å…è¨±å¤šå€‹ç›¸åŒå…ƒç´ ï¼ˆé‡è¤‡å…ƒç´ ï¼‰å­˜åœ¨æ–¼é›†åˆä¸­ã€‚  
åº•å±¤ä¾ç„¶æ˜¯å“ˆå¸Œè¡¨çµæ§‹ï¼Œæ“ä½œå¹³å‡æ™‚é–“è¤‡é›œåº¦ç‚º O(1)ã€‚

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`ums.insert(val)`|æ’å…¥å…ƒç´ ï¼Œå…è¨±é‡è¤‡|
|`ums.erase(val)`|ç§»é™¤æ‰€æœ‰åŒ¹é…å…ƒç´ |
|`ums.erase(it)`|ç§»é™¤æŒ‡å®š iterator çš„å…ƒç´ |
|`ums.find(val)`|æŸ¥æ‰¾ç¬¬ä¸€å€‹åŒ¹é…å…ƒç´ çš„ iterator|
|`ums.count(val)`|å›å‚³è©²å…ƒç´ å‡ºç¾çš„æ¬¡æ•¸|
|`ums.begin(), ums.end()`|è¿­ä»£å™¨ç¯„åœ|
|`ums.bucket_count()`|æ¡¶æ•¸|
|`ums.load_factor()`|è¼‰å…¥å› å­|
|`ums.rehash(n)`|é‡æ–°é…ç½®æ¡¶æ•¸|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_multiset<int> ums;

    ums.insert(10);
    ums.insert(20);
    ums.insert(10);  // é‡è¤‡å…ƒç´ æœƒè¢«ä¿ç•™

    std::cout << "å…§å®¹: ";
    for (int x : ums)
        std::cout << x << " ";
    std::cout << '\n';

    std::cout << "10 å‡ºç¾æ¬¡æ•¸: " << ums.count(10) << '\n';

    ums.erase(10);  // ç§»é™¤æ‰€æœ‰ 10

    std::cout << "åˆªé™¤ 10 å¾Œå…§å®¹: ";
    for (int x : ums)
        std::cout << x << " ";
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦å¿«é€Ÿå„²å­˜å¤šç­†å¯èƒ½é‡è¤‡çš„è³‡æ–™
    
- åªéœ€åˆ¤æ–·å…ƒç´ å­˜åœ¨èˆ‡çµ±è¨ˆï¼Œä¸é—œå¿ƒé †åº
    

### âš ï¸ æ³¨æ„äº‹é …

- ä¸ä¿è­‰å…ƒç´ éæ­·é †åº
    
- `erase(val)` æœƒç§»é™¤æ‰€æœ‰ç¬¦åˆçš„å…ƒç´ 
    
- é¡å‹é ˆå¯ç”¨æ–¼å“ˆå¸Œèˆ‡ç›¸ç­‰æ¯”è¼ƒ
    

---
## âš¡ `std::unordered_map` â€” å”¯ä¸€éµçš„å“ˆå¸Œéµå€¼å°å®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::unordered_map` æ˜¯ä¸€ç¨®åŸºæ–¼å“ˆå¸Œè¡¨çš„é—œè¯å¼å®¹å™¨ï¼Œå„²å­˜**éµå€¼å°ï¼ˆkey-value pairsï¼‰**ï¼Œ  
æä¾›**å¹³å‡ O(1)** çš„æ’å…¥ã€æŸ¥æ‰¾èˆ‡åˆªé™¤é€Ÿåº¦ï¼Œä¸” key **ä¸å¯é‡è¤‡**ã€‚  
å®ƒä¸åƒ `std::map` æœƒæ’åº keyï¼Œè€Œæ˜¯ä¾ç…§ key çš„ hash å€¼ä¾†çµ„ç¹”è³‡æ–™ã€‚

```cpp
#include <unordered_map>
std::unordered_map<std::string, int> um;
```

### ğŸ§± è³‡æ–™çµæ§‹èˆ‡ç‰¹æ€§

- æ¡ç”¨ **å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰**
    
- æ¯å€‹å…ƒç´ æ˜¯ `std::pair<const Key, T>`
    
- ä¸ä¿è­‰éæ­·é †åºï¼Œä½†æ•ˆèƒ½é€šå¸¸æ¯” `map` å¿«
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`um[key] = val`|æ’å…¥æˆ–æ›´æ–° key å°æ‡‰çš„å€¼ï¼ˆè‹¥ä¸å­˜åœ¨æœƒæ’å…¥ï¼‰|
|`um.at(key)`|å­˜å–å€¼ï¼Œä¸å­˜åœ¨å‰‡æ‹‹ä¾‹å¤–|
|`um.insert({key, val})`|æ’å…¥éµå€¼å°ï¼Œè‹¥ key å­˜åœ¨å‰‡ä¸è®Šå‹•|
|`um.emplace(key, val)`|åŸåœ°å»ºæ§‹éµå€¼å°ï¼ˆæ•ˆèƒ½è¼ƒä½³ï¼‰|
|`um.find(key)`|æ‰¾åˆ° key å°æ‡‰çš„ iterator|
|`um.count(key)`|key æ˜¯å¦å­˜åœ¨ï¼ˆç‚º 0 æˆ– 1ï¼‰|
|`um.erase(key)` / `um.erase(it)`|ç§»é™¤å…ƒç´ |
|`um.begin(), um.end()`|è¿­ä»£å™¨ï¼ˆç„¡æ’åºï¼‰|
|`um.bucket_count()` / `load_factor()`|å“ˆå¸Œè¡¨ç‹€æ…‹è³‡è¨Š|
|`um.rehash(n)`|é‡æ–°é…ç½®æ¡¶æ•¸|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<std::string, int> scores;

    scores["Alice"] = 90;
    scores["Bob"] = 80;
    scores["Charlie"] = 85;

    // ä½¿ç”¨ç¯„åœ for loop
    for (const auto& [name, score] : scores)
        std::cout << name << ": " << score << '\n';

    // æŸ¥æ‰¾èˆ‡æ›´æ–°
    if (scores.count("Bob"))
        scores["Bob"] += 5;

    // at() æœƒæ‹‹ä¾‹å¤–
    try {
        std::cout << "Eve: " << scores.at("Eve") << '\n';
    } catch (const std::out_of_range& e) {
        std::cout << "æ‰¾ä¸åˆ° Eve\n";
    }
}
```

### ğŸ§  ç‰¹åˆ¥æ³¨æ„ï¼š`[]` çš„éš±å«æ’å…¥

```cpp
int x = um["NewKey"]; // å¦‚æœ NewKey ä¸å­˜åœ¨ï¼Œæœƒæ’å…¥ { "NewKey", 0 }
```

èˆ‡ `std::map` ç›¸åŒï¼Œ`[]` æ“ä½œ**æœƒæ’å…¥é è¨­å€¼**ï¼Œå¯èƒ½é€ æˆéé æœŸçš„éµå‡ºç¾ã€‚
### ğŸ§ å®‰å…¨æŸ¥è©¢ï¼ˆä¸å»ºç«‹ keyï¼‰

```cpp
if (um.find("Charlie") != um.end())
    std::cout << um["Charlie"];  // safe
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- éœ€è¦å¿«é€ŸæŸ¥æ‰¾ / æ’å…¥ / æ›´æ–° key-value é…å°è³‡æ–™
    
- ä¸éœ€è¦è‡ªå‹•æ’åºï¼ˆåè€Œé¿å…æ’åºé–‹éŠ·ï¼‰
    
- é¡ä¼¼ã€Œå­—å…¸ã€ã€ã€Œhash tableã€ã€ã€Œè³‡æ–™åº«ç´¢å¼•ã€æ‡‰ç”¨
    

### âš ï¸ æ³¨æ„äº‹é …

- ä¸ä¿è­‰è¼¸å‡ºé †åºï¼Œæ¯æ¬¡åŸ·è¡Œå¯èƒ½ä¸åŒ
    
- key é¡å‹éœ€æ”¯æ´ `std::hash<Key>` èˆ‡ `==` æ¯”è¼ƒ
    
- é¿å…éåº¦ä½¿ç”¨ `[]` æ’å…¥ç„¡æ„ç¾©çš„é è¨­å€¼
    


---
## âš¡ `std::unordered_multimap` â€” å…è¨±é‡è¤‡éµçš„å“ˆå¸Œéµå€¼å°å®¹å™¨

### ğŸ“˜ æ¦‚è¦

`std::unordered_multimap` æ˜¯ `unordered_map` çš„è®Šç¨®ï¼Œå…è¨±æ’å…¥**å¤šå€‹ç›¸åŒçš„ key**ã€‚  
å®ƒä¸æœƒè‡ªå‹•æ’åº keyï¼Œè€Œæ˜¯æ ¹æ“šå“ˆå¸Œå€¼å„²å­˜è³‡æ–™ã€‚æ¯ç­†è³‡æ–™ä»æ˜¯ `pair<const Key, T>`ï¼Œä½† key å¯é‡è¤‡ã€‚

```cpp
#include <unordered_map>
std::unordered_multimap<std::string, int> umm;
```

### ğŸ§± è³‡æ–™çµæ§‹

- åº•å±¤ç‚º **å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰**
    
- æ’å…¥ã€åˆªé™¤ã€æŸ¥æ‰¾çš„å¹³å‡æ™‚é–“è¤‡é›œåº¦ç‚º O(1)
    
- å¤šå€‹ç›¸åŒ key çš„å€¼å½¼æ­¤ç„¡é †åºé—œè¯
    

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`umm.insert({key, val})`|æ’å…¥éµå€¼å°ï¼Œå…è¨±é‡è¤‡ key|
|`umm.emplace(key, val)`|åŸåœ°å»ºæ§‹æ’å…¥|
|`umm.find(key)`|å›å‚³å…¶ä¸­ä¸€å€‹è©² key çš„å…ƒç´  iterator|
|`umm.count(key)`|å›å‚³è©² key å‡ºç¾çš„æ¬¡æ•¸|
|`umm.equal_range(key)`|å›å‚³ pairï¼Œç¯„åœå…§åŒ…å«æ‰€æœ‰ç›¸åŒ key çš„å…ƒç´ |
|`umm.erase(key)` / `umm.erase(it)`|ç§»é™¤æ‰€æœ‰åŒ¹é… key / æŒ‡å®šä½ç½®|
|`umm.begin(), umm.end()`|éæ­·æ‰€æœ‰å…ƒç´ |

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_multimap<std::string, int> umm;

    umm.insert({"Alice", 90});
    umm.insert({"Bob", 80});
    umm.insert({"Alice", 85});  // é‡è¤‡ key

    std::cout << "å…§å®¹:\n";
    for (const auto& [name, score] : umm)
        std::cout << name << ": " << score << '\n';

    // æŸ¥æ‰¾ Alice çš„æ‰€æœ‰åˆ†æ•¸
    auto range = umm.equal_range("Alice");
    std::cout << "Alice æ‰€æœ‰åˆ†æ•¸:\n";
    for (auto it = range.first; it != range.second; ++it)
        std::cout << it->second << '\n';
}
```

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- ä¸€å€‹ key å°æ‡‰å¤šå€‹ valueï¼Œä¾‹å¦‚ï¼š
    
    - ä¸€ä½è€å¸«å°æ‡‰å¤šé–€èª²
        
    - ä¸€å€‹åˆ†é¡å°æ‡‰å¤šå€‹ç”¢å“
        
    - å¤šæ¬¡äº¤æ˜“è¨˜éŒ„ã€log è³‡æ–™ç­‰
        

### âš ï¸ æ³¨æ„äº‹é …

- ä¸æ”¯æ´ `operator[]`ï¼ˆå›  key ä¸å”¯ä¸€ï¼‰
    
- å…ƒç´ éæ­·é †åºä¸ä¿è­‰
    
- é‡è¤‡ key çš„å­˜å–éœ€é€é `equal_range` æˆ–è¿´åœˆ `find()` å¤šæ¬¡æ‰¾
    

### âœ… éæ’åºå®¹å™¨ç¸½çµï¼ˆUnordered Containersï¼‰ï¼š

|å®¹å™¨é¡å‹|æ˜¯å¦æ’åº|æ˜¯å¦å…è¨±é‡è¤‡|å„²å­˜å…§å®¹|
|---|---|---|---|
|`unordered_set`|âŒ|âŒ|å”¯ä¸€å…ƒç´ |
|`unordered_multiset`|âŒ|âœ…|å¯é‡è¤‡å…ƒç´ |
|`unordered_map`|âŒ|âŒ|å”¯ä¸€ key çš„éµå€¼å°|
|`unordered_multimap`|âŒ|âœ…|å¯é‡è¤‡ key çš„éµå€¼å°|

---
# ğŸ” Container Adaptersï¼ˆå®¹å™¨é…æ¥å™¨ï¼‰

**Container Adapter** æ˜¯ä¸€é¡å°è£ç¾æœ‰å®¹å™¨ï¼ˆå¦‚ `deque` æˆ– `vector`ï¼‰çš„å®¹å™¨ï¼Œ  
æä¾›ç‰¹å®šè³‡æ–™çµæ§‹çš„è¡Œç‚ºï¼Œä¾‹å¦‚ã€Œå †ç–Šã€ã€ã€Œä½‡åˆ—ã€ç­‰ã€‚  
å®ƒå€‘ä¸ç›´æ¥æä¾› iteratorï¼Œä¸æ”¯æ´éæ­·ï¼Œä¹Ÿæ²’æœ‰è¤‡é›œçš„æˆå“¡å‡½å¼ï¼Œ  
åƒ…æš´éœ²å‡ºç°¡åŒ–çš„æ“ä½œä»‹é¢ã€‚

## ğŸ§± å¸¸è¦‹çš„ Container Adaptersï¼š

|Adapter é¡å‹|è¡Œç‚º|é è¨­åº•å±¤å®¹å™¨|
|---|---|---|
|`std::stack`|å¾Œé€²å…ˆå‡ºï¼ˆLIFOï¼‰|`deque`|
|`std::queue`|å…ˆé€²å…ˆå‡ºï¼ˆFIFOï¼‰|`deque`|
|`std::priority_queue`|å„ªå…ˆé †åºä½‡åˆ—|`vector` + heap|

---
## ğŸ“¦ `std::stack` â€” å¾Œé€²å…ˆå‡ºå †ç–Šå®¹å™¨ï¼ˆLIFOï¼‰

### ğŸ“˜ æ¦‚è¦

`std::stack` æ˜¯ä¸€å€‹**å¾Œé€²å…ˆå‡ºï¼ˆLIFOï¼‰**çš„å®¹å™¨é…æ¥å™¨ï¼Œ  
å°è£åº•å±¤å®¹å™¨ï¼ˆé€šå¸¸æ˜¯ `deque`ï¼‰ï¼Œè®“ä½ åªèƒ½å¾ä¸€ç«¯é€²å‡ºè³‡æ–™ï¼ˆé ‚ç«¯ topï¼‰ã€‚

```cpp
#include <stack>
std::stack<int> s;
```

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`s.push(val)`|å°‡å…ƒç´ æ¨å…¥å †ç–Š|
|`s.pop()`|ç§»é™¤é ‚ç«¯å…ƒç´ ï¼ˆä¸å›å‚³ï¼‰|
|`s.top()`|å–å¾—é ‚ç«¯å…ƒç´ ï¼ˆä¸ç§»é™¤ï¼‰|
|`s.empty()`|æ˜¯å¦ç‚ºç©º|
|`s.size()`|å…ƒç´ å€‹æ•¸|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    s.push(10);
    s.push(20);
    s.push(30);  // ç¾åœ¨å †ç–Šæ˜¯ [10, 20, 30]

    std::cout << "é ‚ç«¯å…ƒç´ : " << s.top() << '\n';  // 30

    s.pop();  // ç§»é™¤ 30
    std::cout << "ç¾åœ¨é ‚ç«¯: " << s.top() << '\n';  // 20

    std::cout << "å‰©é¤˜å…ƒç´ æ•¸: " << s.size() << '\n';
}
```

### âš™ï¸ åº•å±¤å®¹å™¨é¸æ“‡

```cpp
std::stack<int, std::vector<int>> s1;
std::stack<int, std::deque<int>> s2;  // é è¨­
```

`std::stack` å¯è‡ªè¨‚åº•å±¤å®¹å™¨ï¼Œä½†å¿…é ˆæ”¯æ´ï¼š

- `back()`ã€`push_back()`ã€`pop_back()` ç­‰æ“ä½œ
    

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- æ¨¡æ“¬å †ç–Šçµæ§‹ï¼ˆå‘¼å«å †ç–Šã€æ‹¬è™Ÿæ¯”å°ã€DFS ç­‰ï¼‰
    
- ä¸éœ€è¦éš¨æ©Ÿå­˜å–æˆ–éæ­·ï¼Œåªéœ€æ§åˆ¶é ‚ç«¯å…ƒç´ 
    

### âš ï¸ æ³¨æ„äº‹é …

- **ä¸èƒ½éæ­·ï¼** æ²’æœ‰ iterator
    
- `pop()` **ä¸æœƒå›å‚³å€¼**ï¼ˆå¦‚éœ€åŒæ™‚å–å‡ºè«‹æ­é… `top()`ï¼‰
    
- è‹¥éœ€è¦éš¨æ©Ÿå­˜å–æˆ–æ’åºï¼Œè«‹ä½¿ç”¨å…¶ä»–å®¹å™¨ï¼ˆå¦‚ `vector` æˆ– `deque`ï¼‰
    

---
## ğŸ“¬ `std::queue` â€” å…ˆé€²å…ˆå‡ºä½‡åˆ—å®¹å™¨ï¼ˆFIFOï¼‰

### ğŸ“˜ æ¦‚è¦

`std::queue` æ˜¯ä¸€ç¨®**å…ˆé€²å…ˆå‡ºï¼ˆFIFOï¼‰**çš„å®¹å™¨é…æ¥å™¨ï¼Œ  
åªå…è¨±å¾ä¸€ç«¯æ’å…¥ï¼ˆ`back`ï¼‰ï¼Œå¾å¦ä¸€ç«¯ç§»é™¤ï¼ˆ`front`ï¼‰ã€‚  
é è¨­åº•å±¤ä½¿ç”¨ `std::deque`ï¼Œä½†ä¹Ÿå¯ä½¿ç”¨ `list` ç­‰æ”¯æ´é›™ç«¯æ“ä½œçš„å®¹å™¨ã€‚

```cpp
#include <queue>
std::queue<int> q;
```

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`q.push(val)`|å°‡å…ƒç´ åŠ å…¥éšŠå°¾ï¼ˆenqueueï¼‰|
|`q.pop()`|ç§»é™¤å‰ç«¯å…ƒç´ ï¼ˆdequeueï¼‰ï¼Œä¸å›å‚³|
|`q.front()`|å­˜å–éšŠé¦–å…ƒç´ ï¼ˆæœ€æ—©é€²ä¾†çš„ï¼‰|
|`q.back()`|å­˜å–éšŠå°¾å…ƒç´ ï¼ˆæœ€æ–°é€²ä¾†çš„ï¼‰|
|`q.empty()`|æª¢æŸ¥æ˜¯å¦ç‚ºç©º|
|`q.size()`|å‚³å›å…ƒç´ æ•¸é‡|

### ğŸ“Œ ç¯„ä¾‹ç¨‹å¼ç¢¼

```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<std::string> q;

    q.push("apple");
    q.push("banana");
    q.push("cherry");

    std::cout << "å‰ç«¯: " << q.front() << '\n';  // apple
    std::cout << "å¾Œç«¯: " << q.back() << '\n';   // cherry

    q.pop();  // ç§»é™¤ apple

    std::cout << "ç§»é™¤å¾Œå‰ç«¯: " << q.front() << '\n';  // banana
    std::cout << "å‰©é¤˜æ•¸é‡: " << q.size() << '\n';
}
```

### âš™ï¸ åº•å±¤å®¹å™¨è‡ªè¨‚ï¼ˆå¯é¸ï¼‰

```cpp
std::queue<int, std::deque<int>> q1;  // é è¨­
std::queue<int, std::list<int>> q2;   // ä¹Ÿå¯ä½¿ç”¨ list
```

åº•å±¤å®¹å™¨å¿…é ˆæ”¯æ´ï¼š

- `push_back()`ã€`pop_front()`ã€`front()`ã€`back()`
    

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- æ¨¡æ“¬æ’éšŠã€è³‡æºç­‰å¾…ã€BFSï¼ˆå»£åº¦å„ªå…ˆæœå°‹ï¼‰
    
- è³‡æ–™æŒ‰æ™‚é–“é †åºè™•ç†ï¼Œå¾æœ€æ—©åˆ°æœ€æ™š
    
- ä»»å‹™ä½‡åˆ—ã€äº‹ä»¶è™•ç†å™¨
    

### âš ï¸ æ³¨æ„äº‹é …

- **ä¸èƒ½éš¨æ©Ÿå­˜å–æˆ–éæ­·ï¼** æ²’æœ‰ iterator
    
- `pop()` ä¸æœƒå›å‚³å€¼ï¼ˆå–å€¼å‰è«‹å…ˆ `front()`ï¼‰
    
- è‹¥éœ€å„ªå…ˆè™•ç†é †åºä¸åŒçš„è³‡æ–™ï¼Œè«‹ç”¨ `priority_queue`
    

---
## ğŸ”ï¸ `std::priority_queue` â€” å„ªå…ˆä½‡åˆ—ï¼ˆé è¨­ç‚ºæœ€å¤§å †ï¼‰

### ğŸ“˜ æ¦‚è¦

`std::priority_queue` æ˜¯ä¸€ç¨® **å †ç©ï¼ˆheapï¼‰çµæ§‹** çš„å®¹å™¨é…æ¥å™¨ï¼Œ  
æä¾›**æ¯æ¬¡å–å‡ºæœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰**çš„åŠŸèƒ½ï¼Œå¸¸ç”¨æ–¼æ’ç¨‹ã€æœ€ä½³åŒ–æ¼”ç®—æ³•ï¼ˆå¦‚ Dijkstraï¼‰ã€‚  
åº•å±¤å¯¦ä½œç‚º `std::vector` åŠ ä¸Š `make_heap`ã€`push_heap`ã€`pop_heap` ç­‰ heap æ“ä½œã€‚

```cpp
#include <queue>
std::priority_queue<int> pq;  // é è¨­ç‚º max-heap
```

### ğŸ”§ å¸¸è¦‹æ“ä½œèˆ‡æˆå“¡å‡½å¼

|æ–¹æ³• / æˆå“¡|èªªæ˜|
|---|---|
|`pq.push(val)`|æ’å…¥å…ƒç´ ï¼ˆè‡ªå‹•ç¶­æŒ heapï¼‰|
|`pq.pop()`|ç§»é™¤é ‚ç«¯å…ƒç´ ï¼ˆæœ€å¤§æˆ–æœ€å°ï¼‰|
|`pq.top()`|å­˜å–é ‚ç«¯å…ƒç´ |
|`pq.empty()`|æ˜¯å¦ç‚ºç©º|
|`pq.size()`|å…ƒç´ æ•¸é‡|

### ğŸ“Œ ç¯„ä¾‹ï¼šæœ€å¤§å †ï¼ˆé è¨­è¡Œç‚ºï¼‰

```cpp
#include <iostream>
#include <queue>

int main() {
    std::priority_queue<int> pq;

    pq.push(10);
    pq.push(30);
    pq.push(20);

    std::cout << "æœ€å¤§å…ƒç´ : " << pq.top() << '\n';  // 30

    pq.pop();
    std::cout << "ä¸‹ä¸€å€‹æœ€å¤§: " << pq.top() << '\n';  // 20
}
```

### ğŸ“Œ ç¯„ä¾‹ï¼šæœ€å°å †ï¼ˆmin-heapï¼‰

```cpp
#include <queue>
#include <vector>
#include <functional>

std::priority_queue<int, std::vector<int>, std::greater<>> minHeap;
```

é€™è£¡ `greater<>` æ˜¯æ¯”è¼ƒå‡½å¼ï¼Œè®“å †é ‚æ˜¯æœ€å°å€¼ã€‚


> [!info] 
> ç‚ºä»€éº¼ `std::priority_queue` åŠ ä¸Š `greater` å°±æœƒè®Šæˆ **min-heap**ï¼Ÿ  
> å®ƒè·Ÿ `heapify` çš„æ’åºåŸç†æœ‰ä»€éº¼é—œä¿‚ï¼Ÿ

### ğŸ§© `std::priority_queue` æ’åºæ˜¯æ€éº¼æ±ºå®šçš„ï¼Ÿ

### ğŸ“¦ priority_queue é è¨­å®šç¾©ï¼š

```cpp
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```

> âœ… å®ƒçš„æ’åºè¦å‰‡ä¸æ˜¯ã€Œå¤§æ”¾å‰é¢ã€æˆ–ã€Œå°æ”¾å‰é¢ã€ï¼Œè€Œæ˜¯ç”± `Compare` ä¾†æ±ºå®šã€Œå“ªå€‹å…ƒç´ å„ªå…ˆã€  
> â— ä½ å¯ä»¥æŠŠ `Compare(a, b)` ç†è§£ç‚ºï¼šã€Œa æ˜¯å¦æ‡‰è©²æ’åœ¨ b çš„**å¾Œé¢**ï¼Ÿã€

### ğŸ§  äº†è§£ `std::less` èˆ‡ `std::greater`

|Comparator|è¡¨é”æ„ç¾©|æ’åºçµæœ|å°æ‡‰å †|
|---|---|---|---|
|`std::less<T>`|a < b æˆç«‹ â†’ b æ¯” a å„ªå…ˆ|æœ€å¤§å€¼åœ¨é ‚éƒ¨|Max-Heapï¼ˆé è¨­ï¼‰|
|`std::greater<T>`|a > b æˆç«‹ â†’ b æ¯” a å„ªå…ˆ|æœ€å°å€¼åœ¨é ‚éƒ¨|Min-Heap|

### ğŸ” æ›å¥è©±èªªï¼Œ`priority_queue` æ˜¯é€™æ¨£åˆ¤æ–·é †åºçš„ï¼š

```cpp
if (Compare(a, b)) {
    // é‚£éº¼ b å„ªå…ˆ â†’ b æ”¾åœ¨ heap æ›´é«˜çš„ä½ç½®ï¼ˆé è¿‘ rootï¼‰
}
```

#### âœ… èˆ‰ä¾‹ï¼š

```cpp
std::priority_queue<int, std::vector<int>, std::greater<>> pq;
```

æ’å…¥é †åºï¼š`5, 3, 7`

æ’å…¥å¾Œçš„é †åºæœƒæ ¹æ“š `std::greater` ä¾†å»ºå †ï¼š

- æ¯”è¼ƒæ™‚æœƒå•ï¼šã€Œa > b å—ï¼Ÿã€
    
    - è‹¥æ˜¯ï¼Œé‚£éº¼ b è¦å„ªå…ˆï¼Œb æ’åœ¨å‰é¢ â†’ å½¢æˆã€Œæœ€å°å€¼åœ¨é ‚éƒ¨ã€çš„ heap
        
#### âœ… è¦–è¦ºä¾‹å­ï¼š

```cpp
std::priority_queue<int, std::vector<int>, std::greater<>> pq;
pq.push(5);
pq.push(3);
pq.push(7);
```

å½¢æˆçš„ heap æ˜¯é€™æ¨£çš„ min-heapï¼š

```
       3
      / \
     5   7
```

### ğŸ“Œ ç¯„ä¾‹ï¼š`pair` è‡ªè¨‚æ¯”è¼ƒï¼ˆä¾‹å¦‚ï¼šDijkstraï¼‰

```cpp
#include <queue>
#include <vector>
#include <functional>

using pii = std::pair<int, int>;  // {cost, node}
std::priority_queue<pii, std::vector<pii>, std::greater<>> dijkstra;
```

`greater<>` æœƒæ ¹æ“š pair ç¬¬ä¸€å€‹å…ƒç´ ï¼ˆcostï¼‰å¾å°æ’åˆ°å¤§ã€‚

### ğŸš€ é©ç”¨æƒ…å¢ƒ

- æ¯æ¬¡éƒ½è¦å¿«é€Ÿå–å¾—æœ€å¤§æˆ–æœ€å°å€¼
    
- æ¼”ç®—æ³•ï¼šDijkstraã€A*ã€K-th largest/smallest
    
- æ’ç¨‹ç³»çµ±ã€ä»»å‹™å„ªå…ˆæ¬Šç®¡ç†
    

### âš ï¸ æ³¨æ„äº‹é …

- **ä¸èƒ½éæ­·ï¼** æ²’æœ‰ iterator
    
- ä¸æ”¯æ´ä¸­é–“åˆªé™¤ï¼Œåªèƒ½æ“ä½œ top
    
- è‹¥éœ€è‡ªè¨‚æ’åºï¼Œéœ€æä¾›è‡ªå®š comparator æˆ– `greater<>`
    
### ğŸ“¦ Container Adapters ç¸½çµï¼š

| é¡å‹               | è¡Œç‚º   | ä¸»è¦æ“ä½œ                           | åº•å±¤å®¹å™¨ï¼ˆé è¨­ï¼‰ |
| ---------------- | ---- | ------------------------------ | -------- |
| `stack`          | LIFO | `push`, `pop`, `top`           | `deque`  |
| `queue`          | FIFO | `push`, `pop`, `front`, `back` | `deque`  |
| `priority_queue` | heap | `push`, `pop`, `top`           | `vector` |

---

# âš™ï¸ æ¼”ç®—æ³•é€šå¸¸éœ€è¦é¡å¤–è³‡è¨Šä¾†åŸ·è¡Œå·¥ä½œ

è¨±å¤š STL æ¼”ç®—æ³•éœ€è¦é¡å¤–æä¾›**æ¢ä»¶**æˆ–**è¡Œç‚º**ï¼Œä¾†æ±ºå®šå¦‚ä½•è™•ç†è³‡æ–™ï¼Œä¾‹å¦‚æ¯”è¼ƒå¤§å°ã€éæ¿¾æ¢ä»¶ç­‰ã€‚é€™äº›å¯é€éä»¥ä¸‹æ–¹å¼æä¾›ï¼š

## ğŸ§± 1. Functorsï¼ˆå‡½å¼ç‰©ä»¶ï¼‰

### âœ… å®šç¾©

Functor æ˜¯ä¸€å€‹**é‡è¼‰äº† `operator()` çš„é¡åˆ¥æˆ–çµæ§‹é«”ï¼ˆstructï¼‰**ï¼Œè®“å…¶ç‰©ä»¶å¯ä»¥åƒå‡½å¼ä¸€æ¨£è¢«å‘¼å«ã€‚å®ƒçš„å„ªé»åŒ…æ‹¬ï¼š

- å¯ä»¥å°è£ç‹€æ…‹ï¼ˆstatefulï¼‰
    
- æ”¯æ´ template åŒ–èˆ‡è¤‡é›œé‚è¼¯
    
- å¤šç”¨æ–¼éœ€è¦é«˜æ•ˆçš„æ¼”ç®—æ³•ä¸­
    

### ğŸ“Œ èªæ³•ç¯„ä¾‹

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct IsOdd {
    bool operator()(int x) const {
        return x % 2 != 0;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    auto it = std::find_if(vec.begin(), vec.end(), IsOdd());

    if (it != vec.end()) {
        std::cout << "First odd number: " << *it << '\n';
    }
}

```

### ğŸ§  å„ªé»

- å¯ä»¥å„²å­˜å…§éƒ¨ç‹€æ…‹ï¼ˆe.g. ç´¯ç©è¨ˆæ•¸ã€æŒ‡å®šé–¾å€¼ï¼‰
    
- ç·¨è­¯å™¨å„ªåŒ–å‹å–„ï¼ˆinline expansionï¼‰
    

## ğŸ§­ 2. Function Pointersï¼ˆå‡½å¼æŒ‡æ¨™ï¼‰

### âœ… å®šç¾©

Function pointer æ˜¯ä¸€å€‹æŒ‡å‘æ™®é€šå‡½å¼çš„æŒ‡æ¨™ï¼Œå¯ä»¥å°‡ä¸€å€‹å·²æœ‰çš„å‡½å¼å‚³çµ¦ STL æ¼”ç®—æ³•ä½¿ç”¨ã€‚é©ç”¨æ–¼ç°¡å–®ã€ä¸éœ€é¡å¤–ç‹€æ…‹çš„æ¯”è¼ƒæˆ–é‚è¼¯ã€‚

### ğŸ“Œ èªæ³•ç¯„ä¾‹
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool descending(int a, int b) {
    return a > b;
}

int main() {
    std::vector<int> vec = {4, 2, 5, 1, 3};
    
    std::sort(vec.begin(), vec.end(), descending);

    for (int x : vec) std::cout << x << ' ';
    std::cout << '\n';
}

```


### ğŸ§  å„ªé»

- èªæ³•ç°¡å–®ï¼Œå®¹æ˜“é–±è®€
    
- é©åˆç„¡ç‹€æ…‹çš„é‚è¼¯
    
- å¯é‡ç”¨å·²å®šç¾©å‡½å¼
    

### âš ï¸ ç¼ºé»

- ç„¡æ³•å°è£ç‹€æ…‹
    
- ç„¡æ³•å…§åµŒç°¡å–®é‚è¼¯ï¼ˆéœ€é¡å¤–å®šç¾©å‡½å¼ï¼‰

## âš¡ 3. Lambda Expressions(C++11 ä¹‹å¾Œ)
[Lambda Expression](01%20-%20ç¨‹å¼èªè¨€/Beginning%20C++%20Programming%20-%20From%20Beginner%20to%20Beyond/Section%2021%20Lambda%20Expression.md)

---
# ğŸ§® STL æ¼”ç®—æ³• Algorithms

STL æä¾›äº†è¨±å¤šå¸¸è¦‹ä¸”å¯¦ç”¨çš„æ¼”ç®—æ³•ï¼ˆalgorithmsï¼‰ï¼Œå¯æ“ä½œæ–¼å„ç¨®å®¹å™¨å…ƒç´ çš„åºåˆ—ï¼ˆsequences of container elementsï¼‰ï¼Œé€™äº›åºåˆ—æ˜¯é€é **iterator** æä¾›çµ¦æ¼”ç®—æ³•ä½¿ç”¨çš„ã€‚

- STL ä¸­çš„æ¼”ç®—æ³•æ•¸é‡çœ¾å¤šï¼Œç„¡æ³•åœ¨æ­¤ä¸€ä¸€è©³è¿°ã€‚
    
- æ¼”ç®—æ³•æ¶µè“‹äº†æ’åºï¼ˆsortingï¼‰ã€æœå°‹ï¼ˆsearchingï¼‰ã€ä¿®æ”¹ï¼ˆmodifyingï¼‰ã€è¨ˆç®—ï¼ˆnumeric operationsï¼‰ç­‰æ“ä½œã€‚
    
- è©³ç´°åˆ—è¡¨å¯åƒè€ƒå®˜æ–¹æ–‡æª”ï¼š  
    ğŸ”— [cppreference.com/w/cpp/algorithm](http://en.cppreference.com/w/cpp/algorithm)
    

## ğŸ“Œ `std::sort` â€” æ’åºå…ƒç´ ç¯„åœ

### ğŸ”· èªªæ˜

`std::sort` æ˜¯ `<algorithm>` æ¨™é ­æª”ä¸­çš„æ’åºæ¼”ç®—æ³•ï¼Œç”¨æ–¼**å°‡ç¯„åœå…§çš„å…ƒç´ é‡æ–°æ’åˆ—ç‚ºéå¢é †åº**ï¼Œæˆ–é€éè‡ªè¨‚æ¯”è¼ƒæ¢ä»¶æ’åºã€‚ä½¿ç”¨éš¨æ©Ÿå­˜å–è¿­ä»£å™¨ï¼ˆå¦‚ `vector`ã€`deque`ï¼‰é‹ä½œï¼ŒåŸºæ–¼ **introsort**ï¼ˆæ··åˆ quicksortã€heapsortã€insertionsortï¼‰ä»¥é”åˆ°é«˜æ•ˆæ’åºã€‚

### ğŸ”§ èªæ³•

```cpp
// é è¨­ä½¿ç”¨ operator< æ’åº
template< class RandomIt >
void sort( RandomIt first, RandomIt last );

// ä½¿ç”¨è‡ªè¨‚æ¯”è¼ƒå‡½å¼
template< class RandomIt, class Compare >
void sort( RandomIt first, RandomIt last, Compare comp );
```

### ğŸ§  åƒæ•¸èªªæ˜

| åƒæ•¸              | èªªæ˜                                                                                                  |
| --------------- | --------------------------------------------------------------------------------------------------- |
| `first`, `last` | è¦æ’åºçš„ç¯„åœ `[first, last)`ï¼Œéœ€ç‚º Random Access Iteratorã€‚                                                   |
| `comp`          | æ¯”è¼ƒå‡½å¼ï¼ˆå¯ç‚º function pointer, functor, æˆ– lambdaï¼‰ï¼Œå›å‚³ `bool`ã€‚å¦‚æœ `comp(a, b)` å›å‚³ `true`ï¼Œè¡¨ç¤º `a` æœƒæ’åœ¨ `b` å‰é¢ã€‚ |

### ğŸ“ˆ æ™‚é–“è¤‡é›œåº¦

- æœ€ä½³æƒ…æ³ï¼š`O(n log n)`
    
- å¹³å‡æƒ…æ³ï¼š`O(n log n)`
    
- æœ€å·®æƒ…æ³ï¼š`O(n log n)`ï¼ˆå› ç‚ºä½¿ç”¨ introsortï¼‰
    

### ğŸ§ª ç¯„ä¾‹ 1ï¼šæ’åº primitive typeï¼ˆintï¼‰

#### âœ… ä½¿ç”¨é è¨­ `<`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {4, 2, 5, 1, 3};

    std::sort(v.begin(), v.end());

    for (int x : v) std::cout << x << ' ';
    // è¼¸å‡ºï¼š1 2 3 4 5
}
```

#### âœ… ä½¿ç”¨ lambda è‡ªè¨‚éæ¸›æ’åº

```cpp
std::sort(v.begin(), v.end(), [](int a, int b) {
    return a > b;
});
// è¼¸å‡ºï¼š5 4 3 2 1
```

### ğŸ§ª ç¯„ä¾‹ 2ï¼šæ’åº user-defined typeï¼ˆstructï¼‰

#### ğŸ§± å®šç¾©è³‡æ–™çµæ§‹

```cpp
struct Student {
    std::string name;
    int score;
};
```

#### âœ… ä½¿ç”¨ functor ä¾ç…§ score éæ¸›æ’åº

```cpp
struct CompareByScoreDesc {
    bool operator()(const Student& a, const Student& b) const {
        return a.score > b.score;
    }
};

std::vector<Student> students = {
    {"Alice", 90}, {"Bob", 75}, {"Charlie", 85}
};

std::sort(students.begin(), students.end(), CompareByScoreDesc{});
```

#### âœ… ä½¿ç”¨ lambda è¡¨é”å¼ä¾ç…§ name æ’åº

```cpp
std::sort(students.begin(), students.end(),
    [](const Student& a, const Student& b) {
        return a.name < b.name;
    });
```

#### ğŸ“˜ è£œå……èªªæ˜

- `std::sort` **ä¸ç©©å®š**ï¼ˆç›¸åŒå…ƒç´ çš„é †åºä¸ä¸€å®šä¿ç•™ï¼‰ï¼Œè‹¥éœ€è¦ç©©å®šæ’åºè«‹ä½¿ç”¨ `std::stable_sort`ã€‚
    
- æ¯”è¼ƒå‡½å¼éœ€ç¬¦åˆ**åš´æ ¼å¼±æ’åº(Strict Weak Ordering)** è¦å‰‡ï¼Œå¦å‰‡çµæœæœªå®šç¾©ã€‚
    
- å¯ç”¨æ–¼ `std::vector`ã€`std::deque` ç­‰ï¼Œä½† **ä¸å¯ç”¨æ–¼ `std::list`**ï¼ˆå› å…¶ç‚º bidirectional iteratorï¼Œè«‹æ”¹ç”¨ `list::sort()`ï¼‰


## ğŸ” `std::find_if` â€” æ‰¾å‡ºç¬¦åˆæ¢ä»¶çš„ç¬¬ä¸€å€‹å…ƒç´ 

### ğŸ”· èªªæ˜

`std::find_if` æ˜¯ `<algorithm>` æ¨™é ­æª”ä¸­çš„æœå°‹æ¼”ç®—æ³•ï¼Œç”¨ä¾†**åœ¨ç¯„åœä¸­å°‹æ‰¾ç¬¬ä¸€å€‹æ»¿è¶³æ¢ä»¶çš„å…ƒç´ **ï¼Œæ¢ä»¶ç”±ä¸€å€‹å¯å‘¼å«å°è±¡ï¼ˆpredicateï¼‰æ±ºå®šã€‚

### ğŸ”§ èªæ³•

```cpp
template< class InputIt, class UnaryPredicate >
InputIt find_if( InputIt first, InputIt last, UnaryPredicate p );
```

### ğŸ§  åƒæ•¸èªªæ˜

|åƒæ•¸|èªªæ˜|
|---|---|
|`first`, `last`|è¦æœå°‹çš„ç¯„åœ `[first, last)`ï¼Œéœ€ç‚º Input Iteratorã€‚|
|`p`|ä¸€å…ƒè¿°è©ï¼ˆunary predicateï¼‰ï¼Œå¯ç‚º function pointerã€functor æˆ– lambdaï¼Œæ¥æ”¶ä¸€å€‹åƒæ•¸ä¸¦å›å‚³ `bool`ã€‚|

### ğŸ“ˆ æ™‚é–“è¤‡é›œåº¦

- æœ€å£æƒ…æ³ï¼šæœ€å¤šå‘¼å« `p` æ¬¡æ•¸ç‚ºè·é›¢ `last - first`
    
- å¹³å‡æ™‚é–“ï¼šç·šæ€§ O(n)
    

### ğŸ§ª ç¯„ä¾‹ 1ï¼šæœå°‹ primitive type

#### âœ… æ‰¾å‡ºç¬¬ä¸€å€‹å¥‡æ•¸

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {2, 4, 6, 7, 8};

    auto it = std::find_if(v.begin(), v.end(), [](int x) {
        return x % 2 != 0;
    });

    if (it != v.end()) {
        std::cout << "First odd: " << *it << '\n'; // è¼¸å‡ºï¼š7
    }
}
```

### ğŸ§ª ç¯„ä¾‹ 2ï¼šæœå°‹ user-defined type

#### ğŸ§± å®šç¾©è³‡æ–™çµæ§‹

```cpp
struct Student {
    std::string name;
    int score;
};
```

#### âœ… æ‰¾å‡ºç¬¬ä¸€å€‹åŠæ ¼çš„å­¸ç”Ÿï¼ˆscore >= 60ï¼‰

```cpp
std::vector<Student> students = {
    {"Alice", 55}, {"Bob", 40}, {"Charlie", 75}, {"David", 60}
};

auto it = std::find_if(students.begin(), students.end(), [](const Student& s) {
    return s.score >= 60;
});

if (it != students.end()) {
    std::cout << "First passing student: " << it->name << '\n'; // Charlie
}
```

#### ğŸ“˜ è£œå……èªªæ˜

- `find_if` å›å‚³ç¬¬ä¸€å€‹ä½¿è¿°è© `p(x)` ç‚º `true` çš„å…ƒç´ çš„ iteratorï¼Œè‹¥ç„¡å‰‡å›å‚³ `last`ã€‚
    
- è‹¥æœå°‹å›ºå®šå€¼ï¼ˆéæ¢ä»¶ï¼‰ï¼Œå¯ä½¿ç”¨ `std::find`ï¼š
    
    ```cpp
    std::find(v.begin(), v.end(), 42);
    ```
    
- è‹¥éœ€æœå°‹æœ€å¾Œä¸€å€‹æ»¿è¶³æ¢ä»¶çš„å…ƒç´ ï¼Œè«‹ä½¿ç”¨ `std::find_if` çµåˆ `std::reverse_iterator` æˆ–è€ƒæ…® `std::ranges::find_if`ï¼ˆC++20ï¼‰ã€‚
    

## ğŸ” `std::for_each` â€” å°ç¯„åœå…§æ¯å€‹å…ƒç´ åŸ·è¡ŒæŒ‡å®šæ“ä½œ
### ğŸ”· èªªæ˜

`std::for_each` æœƒéæ­·å€é–“ `[first, last)` ä¸­çš„æ¯å€‹å…ƒç´ ï¼Œä¸¦å°‡æ¯å€‹å…ƒç´ å‚³å…¥ä¸€å€‹å¯å‘¼å«å°è±¡ï¼ˆå‡½å¼ã€å‡½å¼ç‰©ä»¶ã€æˆ– lambdaï¼‰ä¸­åŸ·è¡Œã€‚å¸¸ç”¨æ–¼**åŸ·è¡Œå‰¯ä½œç”¨æ“ä½œ**ï¼ˆå¦‚åˆ—å°ã€ç´¯åŠ ã€ä¿®æ”¹ç­‰ï¼‰ã€‚

### ğŸ”§ èªæ³•

```cpp
template< class InputIt, class UnaryFunction >
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );
```

### ğŸ§  åƒæ•¸èªªæ˜

|åƒæ•¸|èªªæ˜|
|---|---|
|`first`, `last`|è¦éæ­·çš„ç¯„åœ `[first, last)`ï¼Œéœ€ç‚º Input Iteratorã€‚|
|`f`|ä¸€å…ƒå‡½å¼ï¼ˆunary functionï¼‰ï¼Œæ¥æ”¶å…ƒç´ åƒè€ƒæˆ–å€¼ï¼Œé€šå¸¸å›å‚³ `void`ï¼Œä¹Ÿå¯ç‚ºå‡½å¼ç‰©ä»¶ï¼ˆæ”¯æŒç´¯ç©ç‹€æ…‹ï¼‰ã€‚|

### ğŸ“ˆ æ™‚é–“è¤‡é›œåº¦

- ç·šæ€§ O(n)ï¼Œéœ€éæ­·æ‰€æœ‰å…ƒç´ 
    

### ğŸ§ª ç¯„ä¾‹ 1ï¼šprimitive types â€” åˆ—å°æ‰€æœ‰å…ƒç´ 

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    std::for_each(v.begin(), v.end(), [](int x) {
        std::cout << x << ' ';
    });
    // è¼¸å‡ºï¼š1 2 3 4 5
}
```

### ğŸ§ª ç¯„ä¾‹ 2ï¼šuser-defined type â€” ä¿®æ”¹æˆå“¡å€¼ä¸¦åˆ—å°

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Student {
    std::string name;
    int score;
};

int main() {
    std::vector<Student> students = {
        {"Alice", 70}, {"Bob", 85}, {"Charlie", 90}
    };

    // æå‡æ¯å€‹å­¸ç”Ÿ 5 åˆ†
    std::for_each(students.begin(), students.end(), [](Student& s) {
        s.score += 5;
    });

    // åˆ—å°çµæœ
    std::for_each(students.begin(), students.end(), [](const Student& s) {
        std::cout << s.name << ": " << s.score << '\n';
    });
}
```

### ğŸ§ª ç¯„ä¾‹ 3ï¼šstateful functor / lambda â€” ç´¯åŠ å…ƒç´ å’Œ

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    int sum = 0;

    // æ•æ‰å¤–éƒ¨è®Šæ•¸ sumï¼Œç´¯åŠ æ¯å€‹å…ƒç´ 
    std::for_each(v.begin(), v.end(), [&sum](int x) {
        sum += x;
    });

    std::cout << "Sum = " << sum << '\n';  // è¼¸å‡ºï¼šSum = 15
}
```

æˆ–è€…ä½¿ç”¨è‡ªè¨‚ functorï¼š

```cpp
struct Accumulator {
    int total = 0;
    void operator()(int x) { total += x; }
};

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    Accumulator acc = std::for_each(v.begin(), v.end(), Accumulator());
    std::cout << "Sum = " << acc.total << '\n';  // è¼¸å‡ºï¼šSum = 15
}
```

### ğŸ“˜ è£œå……èªªæ˜

- `for_each` æœƒå›å‚³å‚³å…¥çš„å‡½å¼ç‰©ä»¶ï¼ˆé€šå¸¸æ˜¯ç”¨ä¾†ç´¯ç©ç‹€æ…‹çš„ functorï¼‰ï¼Œæ–¹ä¾¿å¾ŒçºŒä½¿ç”¨ã€‚
    
- å°æ–¼ä¸ä¿®æ”¹å…ƒç´ å…§å®¹ï¼Œåªéœ€å‰¯ä½œç”¨æ“ä½œéå¸¸åˆé©ã€‚
    
- C++20 èµ·å¯ä½¿ç”¨ç¯„åœç‰ˆæœ¬ `std::ranges::for_each`ï¼Œèªæ³•æ›´ç°¡æ½”ã€‚
    
---



# ğŸ§  STL ä½¿ç”¨å„ªå‹¢

- ç¯€çœæ™‚é–“ï¼šä¸ç”¨è‡ªå·±é€ è¼ªå­
    
- ç¯€çœéŒ¯èª¤ï¼šç¶“éæ¸¬è©¦ã€æ•ˆç‡é«˜
    
- æ³›å‹è¨­è¨ˆï¼šæ”¯æ´ä»»æ„å‹åˆ¥
    
- çµ„åˆå½ˆæ€§ï¼šå®¹å™¨ï¼‹æ¼”ç®—æ³•ï¼‹ç–Šä»£å™¨ = å¼·å¤§çµ„åˆ
    

---


# ğŸ”¥ Iterator Invalidationï¼ˆç–Šä»£å™¨å¤±æ•ˆï¼‰

### ğŸ“Œ å®šç¾©

**ç–Šä»£å™¨ï¼ˆiteratorï¼‰æ˜¯ä¸€ç¨®æŒ‡å‘å®¹å™¨ä¸­å…ƒç´ çš„ç‰©ä»¶**ï¼Œä½†åœ¨æŸäº›æ“ä½œï¼ˆä¾‹å¦‚æ’å…¥ã€åˆªé™¤ã€æ¸…ç©ºï¼‰å¾Œï¼Œé€™äº› iterator **å¯èƒ½å¤±æ•ˆ**ï¼Œä¹Ÿå°±æ˜¯å®ƒå€‘**ä¸å†æŒ‡å‘æœ‰æ•ˆçš„å…ƒç´ ä½ç½®**ï¼Œè‹¥ç¹¼çºŒä½¿ç”¨ï¼Œæœƒå°è‡´ **æœªå®šç¾©è¡Œç‚ºï¼ˆundefined behaviorï¼‰**ã€‚

---

## âš ï¸ ç•¶ä½ åŸ·è¡ŒæŸäº›æ“ä½œæ™‚ï¼Œæœƒç™¼ç”Ÿä»€éº¼ï¼Ÿ

### ğŸ’¥ Suppose we are iterating over a vector of 10 elements, and we `clear()` the vector while iterating?

é€™æ¨£çš„ç¨‹å¼ç¢¼æœƒå°è‡´**åš´é‡éŒ¯èª¤**ï¼š

```cpp
std::vector<int> v = {1,2,3,4,5,6,7,8,9,10};

for (auto it = v.begin(); it != v.end(); ++it) {
    if (*it == 5) {
        v.clear();  // éŒ¯èª¤ï¼šä½¿æ‰€æœ‰ iterator å¤±æ•ˆ
    }
    std::cout << *it << " ";  // æœªå®šç¾©è¡Œç‚ºï¼ˆå¯èƒ½é–ƒé€€ï¼‰
}
```

ç•¶ `clear()` è¢«å‘¼å«å¾Œï¼Œ`it` å°±è®Šæˆä¸€å€‹ã€Œé‡æŒ‡æ¨™ã€ï¼Œç¹¼çºŒè§£åƒæœƒå°è‡´**è¨˜æ†¶é«”éŒ¯èª¤æˆ–ç•¶æ©Ÿ**ã€‚

---

## ğŸ“Œ å“ªäº›æ“ä½œæœƒä½¿ iterator å¤±æ•ˆï¼Ÿ

é€™å–æ±ºæ–¼å®¹å™¨ç¨®é¡ï¼ˆä»¥ä¸‹æ˜¯æœ€å¸¸è¦‹å®¹å™¨ï¼‰ï¼š

|å®¹å™¨|æœƒä½¿ iterator å¤±æ•ˆçš„æ“ä½œ|å‚™è¨»|
|---|---|---|
|`vector`|`insert()`, `erase()`, `resize()`, `clear()`, `push_back()`ï¼ˆå¦‚å®¹é‡ä¸è¶³ï¼‰|å¯èƒ½å…¨éƒ¨å¤±æ•ˆ|
|`deque`|åŒä¸Š|åŒæ¨£å±éšª|
|`list`|`erase()`, `clear()`|åªæœƒä½¿åˆªé™¤çš„å…ƒç´ çš„ iterator å¤±æ•ˆï¼Œå…¶å®ƒ iterator å®‰å…¨|
|`map` / `set`|`erase()`, `clear()`|æ’å…¥ä¸æœƒå½±éŸ¿æ—¢æœ‰ iteratorï¼Œä½†åˆªé™¤æœƒå¤±æ•ˆ|
|`unordered_map` / `unordered_set`|`insert()`, `erase()`, `rehash()`|rehash æ™‚æœƒå…¨éƒ¨å¤±æ•ˆ|

---

## âœ… æ€éº¼é¿å…ï¼Ÿ

### æ–¹æ³•ä¸€ï¼š**ä¸è¦åœ¨è¿´åœˆä¸­ç›´æ¥ä¿®æ”¹å®¹å™¨å¤§å°**

éŒ¯èª¤ç¤ºç¯„ï¼š

```cpp
for (auto it = v.begin(); it != v.end(); ++it) {
    if (*it % 2 == 0)
        v.erase(it);  // âŒ æœƒå°è‡´ iterator å¤±æ•ˆ
}
```

### æ­£ç¢ºå¯«æ³•ï¼š

```cpp
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0)
        it = v.erase(it);  // âœ”ï¸ erase æœƒå›å‚³ä¸‹ä¸€å€‹æœ‰æ•ˆçš„ iterator
    else
        ++it;
}
```

---

## ğŸ§  å°çµ

| é‡é»                            | èªªæ˜                                 |
| ----------------------------- | ---------------------------------- |
| Iterator æ˜¯å®¹å™¨çš„ã€ŒæŒ‡æ¨™ã€             | å®ƒå€‘çš„æœ‰æ•ˆæ€§å–æ±ºæ–¼å®¹å™¨çš„ç‹€æ…‹                     |
| æŸäº›æ“ä½œæœƒä½¿ iterator å¤±æ•ˆ            | å¦‚ï¼š`clear()`ã€`erase()`ã€`insert()` ç­‰ |
| ä½¿ç”¨å¤±æ•ˆçš„ iterator = æœªå®šç¾©è¡Œç‚º        | å¯èƒ½é–ƒé€€ã€è³‡æ–™éŒ¯äº‚                          |
| é¿å…å¤±æ•ˆï¼šä½¿ç”¨ erase å›å‚³å€¼æˆ–é‡è¨­ iterator | æˆ–ä½¿ç”¨æ–°å®¹å™¨å„²å­˜æ¬²ä¿ç•™è³‡æ–™                      |

---
STL é—œè¯å¼å®¹å™¨çš„ã€Œé€²ä¸€æ­¥èªªæ˜ã€ï¼ŒåŒ…å«ï¼š

1. ğŸ”€ `unordered_map` / `unordered_set` çš„ä»‹ç´¹èˆ‡æ¯”è¼ƒ
    
2. ğŸ§ª ç”¨ `map` å¯¦ä½œå­—é »çµ±è¨ˆï¼ˆæ–‡å­—åˆ†æå¸¸è¦‹æ‡‰ç”¨ï¼‰
    
3. âš–ï¸ ç”¨ `set` å¯¦ä½œé›†åˆé‹ç®—ï¼ˆäº¤é›†ã€è¯é›†ã€å·®é›†ï¼‰
    

---

| æ“ä½œ     | set          | multiset                 | map                          | multimap         |
| ------ | ------------ | ------------------------ | ---------------------------- | ---------------- |
| å®£å‘Š     | `set<int>`   | `multiset<int>`          | `map<K, V>`                  | `multimap<K, V>` |
| æ’å…¥     | `insert(x)`  | `insert(x)`              | `m[k] = v` / `insert({k,v})` | `insert({k,v})`  |
| é‡è¤‡ key | âŒ            | âœ…                        | âŒ                            | âœ…                |
| æŸ¥å€¼     | `find(x)`    | `find(x)`                | `m[k]` / `at(k)`             | `equal_range(k)` |
| åˆªé™¤     | `erase(val)` | `erase(val)` or iterator | `erase(k)`                   | `erase(it)`      |

---